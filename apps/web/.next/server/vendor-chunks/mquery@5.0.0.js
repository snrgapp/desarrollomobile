"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mquery@5.0.0";
exports.ids = ["vendor-chunks/mquery@5.0.0"];
exports.modules = {

/***/ "(rsc)/../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/collection.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/collection.js ***!
  \**********************************************************************************************/
/***/ ((module, exports) => {

eval("\n\n/**\n * methods a collection must implement\n */\n\nconst methods = [\n  'find',\n  'findOne',\n  'updateMany',\n  'updateOne',\n  'replaceOne',\n  'count',\n  'distinct',\n  'findOneAndDelete',\n  'findOneAndUpdate',\n  'aggregate',\n  'findCursor',\n  'deleteOne',\n  'deleteMany'\n];\n\n/**\n * Collection base class from which implementations inherit\n */\n\nfunction Collection() {}\n\nfor (let i = 0, len = methods.length; i < len; ++i) {\n  const method = methods[i];\n  Collection.prototype[method] = notImplemented(method);\n}\n\nmodule.exports = exports = Collection;\nCollection.methods = methods;\n\n/**\n * creates a function which throws an implementation error\n */\n\nfunction notImplemented(method) {\n  return function() {\n    throw new Error('collection.' + method + ' not implemented');\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21xdWVyeUA1LjAuMC9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9jb2xsZWN0aW9uL2NvbGxlY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcZXJpY19cXERlc2t0b3BcXHN5bmVyZ3ktbWF0Y2gtYXBwXFxub2RlX21vZHVsZXNcXC5wbnBtXFxtcXVlcnlANS4wLjBcXG5vZGVfbW9kdWxlc1xcbXF1ZXJ5XFxsaWJcXGNvbGxlY3Rpb25cXGNvbGxlY3Rpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIG1ldGhvZHMgYSBjb2xsZWN0aW9uIG11c3QgaW1wbGVtZW50XG4gKi9cblxuY29uc3QgbWV0aG9kcyA9IFtcbiAgJ2ZpbmQnLFxuICAnZmluZE9uZScsXG4gICd1cGRhdGVNYW55JyxcbiAgJ3VwZGF0ZU9uZScsXG4gICdyZXBsYWNlT25lJyxcbiAgJ2NvdW50JyxcbiAgJ2Rpc3RpbmN0JyxcbiAgJ2ZpbmRPbmVBbmREZWxldGUnLFxuICAnZmluZE9uZUFuZFVwZGF0ZScsXG4gICdhZ2dyZWdhdGUnLFxuICAnZmluZEN1cnNvcicsXG4gICdkZWxldGVPbmUnLFxuICAnZGVsZXRlTWFueSdcbl07XG5cbi8qKlxuICogQ29sbGVjdGlvbiBiYXNlIGNsYXNzIGZyb20gd2hpY2ggaW1wbGVtZW50YXRpb25zIGluaGVyaXRcbiAqL1xuXG5mdW5jdGlvbiBDb2xsZWN0aW9uKCkge31cblxuZm9yIChsZXQgaSA9IDAsIGxlbiA9IG1ldGhvZHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgY29uc3QgbWV0aG9kID0gbWV0aG9kc1tpXTtcbiAgQ29sbGVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IG5vdEltcGxlbWVudGVkKG1ldGhvZCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IENvbGxlY3Rpb247XG5Db2xsZWN0aW9uLm1ldGhvZHMgPSBtZXRob2RzO1xuXG4vKipcbiAqIGNyZWF0ZXMgYSBmdW5jdGlvbiB3aGljaCB0aHJvd3MgYW4gaW1wbGVtZW50YXRpb24gZXJyb3JcbiAqL1xuXG5mdW5jdGlvbiBub3RJbXBsZW1lbnRlZChtZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY29sbGVjdGlvbi4nICsgbWV0aG9kICsgJyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/collection.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/index.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/index.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst env = __webpack_require__(/*! ../env */ \"(rsc)/../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/env.js\");\n\nif ('unknown' == env.type) {\n  throw new Error('Unknown environment');\n}\n\nmodule.exports =\n  env.isNode ? __webpack_require__(/*! ./node */ \"(rsc)/../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/node.js\") :\n    env.isMongo ? __webpack_require__(/*! ./collection */ \"(rsc)/../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/collection.js\") :\n      __webpack_require__(/*! ./collection */ \"(rsc)/../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/collection.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21xdWVyeUA1LjAuMC9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9jb2xsZWN0aW9uL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQywwRkFBUTs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHNHQUFRO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLGtIQUFjO0FBQ3hDLE1BQU0sbUJBQU8sQ0FBQyxrSEFBYyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxlcmljX1xcRGVza3RvcFxcc3luZXJneS1tYXRjaC1hcHBcXG5vZGVfbW9kdWxlc1xcLnBucG1cXG1xdWVyeUA1LjAuMFxcbm9kZV9tb2R1bGVzXFxtcXVlcnlcXGxpYlxcY29sbGVjdGlvblxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBlbnYgPSByZXF1aXJlKCcuLi9lbnYnKTtcblxuaWYgKCd1bmtub3duJyA9PSBlbnYudHlwZSkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW52aXJvbm1lbnQnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPVxuICBlbnYuaXNOb2RlID8gcmVxdWlyZSgnLi9ub2RlJykgOlxuICAgIGVudi5pc01vbmdvID8gcmVxdWlyZSgnLi9jb2xsZWN0aW9uJykgOlxuICAgICAgcmVxdWlyZSgnLi9jb2xsZWN0aW9uJyk7XG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/node.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/node.js ***!
  \****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n\n/**\n * Module dependencies\n */\n\nconst Collection = __webpack_require__(/*! ./collection */ \"(rsc)/../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/collection.js\");\n\nclass NodeCollection extends Collection {\n  constructor(col) {\n    super();\n\n    this.collection = col;\n    this.collectionName = col.collectionName;\n  }\n\n  /**\n   * find(match, options)\n   */\n  async find(match, options) {\n    const cursor = this.collection.find(match, options);\n\n    return cursor.toArray();\n  }\n\n  /**\n   * findOne(match, options)\n   */\n  async findOne(match, options) {\n    return this.collection.findOne(match, options);\n  }\n\n  /**\n   * count(match, options)\n   */\n  async count(match, options) {\n    return this.collection.count(match, options);\n  }\n\n  /**\n   * distinct(prop, match, options)\n   */\n  async distinct(prop, match, options) {\n    return this.collection.distinct(prop, match, options);\n  }\n\n  /**\n   * updateMany(match, update, options)\n   */\n  async updateMany(match, update, options) {\n    return this.collection.updateMany(match, update, options);\n  }\n\n  /**\n   * updateOne(match, update, options)\n   */\n  async updateOne(match, update, options) {\n    return this.collection.updateOne(match, update, options);\n  }\n\n  /**\n   * replaceOne(match, update, options)\n   */\n  async replaceOne(match, update, options) {\n    return this.collection.replaceOne(match, update, options);\n  }\n\n  /**\n   * deleteOne(match, options)\n   */\n  async deleteOne(match, options) {\n    return this.collection.deleteOne(match, options);\n  }\n\n  /**\n   * deleteMany(match, options)\n   */\n  async deleteMany(match, options) {\n    return this.collection.deleteMany(match, options);\n  }\n\n  /**\n   * findOneAndDelete(match, options, function(err[, result])\n   */\n  async findOneAndDelete(match, options) {\n    return this.collection.findOneAndDelete(match, options);\n  }\n\n  /**\n   * findOneAndUpdate(match, update, options)\n   */\n  async findOneAndUpdate(match, update, options) {\n    return this.collection.findOneAndUpdate(match, update, options);\n  }\n\n  /**\n   * var cursor = findCursor(match, options)\n   */\n  findCursor(match, options) {\n    return this.collection.find(match, options);\n  }\n\n  /**\n   * aggregation(operators...)\n   * TODO\n   */\n}\n\n\n/**\n * Expose\n */\n\nmodule.exports = exports = NodeCollection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21xdWVyeUA1LjAuMC9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9jb2xsZWN0aW9uL25vZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBTyxDQUFDLGtIQUFjOztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxlcmljX1xcRGVza3RvcFxcc3luZXJneS1tYXRjaC1hcHBcXG5vZGVfbW9kdWxlc1xcLnBucG1cXG1xdWVyeUA1LjAuMFxcbm9kZV9tb2R1bGVzXFxtcXVlcnlcXGxpYlxcY29sbGVjdGlvblxcbm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbmNvbnN0IENvbGxlY3Rpb24gPSByZXF1aXJlKCcuL2NvbGxlY3Rpb24nKTtcblxuY2xhc3MgTm9kZUNvbGxlY3Rpb24gZXh0ZW5kcyBDb2xsZWN0aW9uIHtcbiAgY29uc3RydWN0b3IoY29sKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuY29sbGVjdGlvbiA9IGNvbDtcbiAgICB0aGlzLmNvbGxlY3Rpb25OYW1lID0gY29sLmNvbGxlY3Rpb25OYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIGZpbmQobWF0Y2gsIG9wdGlvbnMpXG4gICAqL1xuICBhc3luYyBmaW5kKG1hdGNoLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY3Vyc29yID0gdGhpcy5jb2xsZWN0aW9uLmZpbmQobWF0Y2gsIG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIGN1cnNvci50b0FycmF5KCk7XG4gIH1cblxuICAvKipcbiAgICogZmluZE9uZShtYXRjaCwgb3B0aW9ucylcbiAgICovXG4gIGFzeW5jIGZpbmRPbmUobWF0Y2gsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLmZpbmRPbmUobWF0Y2gsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNvdW50KG1hdGNoLCBvcHRpb25zKVxuICAgKi9cbiAgYXN5bmMgY291bnQobWF0Y2gsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLmNvdW50KG1hdGNoLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkaXN0aW5jdChwcm9wLCBtYXRjaCwgb3B0aW9ucylcbiAgICovXG4gIGFzeW5jIGRpc3RpbmN0KHByb3AsIG1hdGNoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi5kaXN0aW5jdChwcm9wLCBtYXRjaCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogdXBkYXRlTWFueShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKVxuICAgKi9cbiAgYXN5bmMgdXBkYXRlTWFueShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi51cGRhdGVNYW55KG1hdGNoLCB1cGRhdGUsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIHVwZGF0ZU9uZShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKVxuICAgKi9cbiAgYXN5bmMgdXBkYXRlT25lKG1hdGNoLCB1cGRhdGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLnVwZGF0ZU9uZShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXBsYWNlT25lKG1hdGNoLCB1cGRhdGUsIG9wdGlvbnMpXG4gICAqL1xuICBhc3luYyByZXBsYWNlT25lKG1hdGNoLCB1cGRhdGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLnJlcGxhY2VPbmUobWF0Y2gsIHVwZGF0ZSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogZGVsZXRlT25lKG1hdGNoLCBvcHRpb25zKVxuICAgKi9cbiAgYXN5bmMgZGVsZXRlT25lKG1hdGNoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi5kZWxldGVPbmUobWF0Y2gsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGRlbGV0ZU1hbnkobWF0Y2gsIG9wdGlvbnMpXG4gICAqL1xuICBhc3luYyBkZWxldGVNYW55KG1hdGNoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi5kZWxldGVNYW55KG1hdGNoLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBmaW5kT25lQW5kRGVsZXRlKG1hdGNoLCBvcHRpb25zLCBmdW5jdGlvbihlcnJbLCByZXN1bHRdKVxuICAgKi9cbiAgYXN5bmMgZmluZE9uZUFuZERlbGV0ZShtYXRjaCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb24uZmluZE9uZUFuZERlbGV0ZShtYXRjaCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogZmluZE9uZUFuZFVwZGF0ZShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKVxuICAgKi9cbiAgYXN5bmMgZmluZE9uZUFuZFVwZGF0ZShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi5maW5kT25lQW5kVXBkYXRlKG1hdGNoLCB1cGRhdGUsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIHZhciBjdXJzb3IgPSBmaW5kQ3Vyc29yKG1hdGNoLCBvcHRpb25zKVxuICAgKi9cbiAgZmluZEN1cnNvcihtYXRjaCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb24uZmluZChtYXRjaCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogYWdncmVnYXRpb24ob3BlcmF0b3JzLi4uKVxuICAgKiBUT0RPXG4gICAqL1xufVxuXG5cbi8qKlxuICogRXhwb3NlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gTm9kZUNvbGxlY3Rpb247XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/node.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/env.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/env.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nexports.isNode = 'undefined' != typeof process\n           && 'object' == \"object\"\n           && 'object' == typeof global\n           && 'function' == typeof Buffer\n           && process.argv;\n\nexports.isMongo = !exports.isNode\n           && 'function' == typeof printjson\n           && 'function' == typeof ObjectId\n           && 'function' == typeof rs\n           && 'function' == typeof sh;\n\nexports.isBrowser = !exports.isNode\n                 && !exports.isMongo\n                 && 'undefined' != typeof window;\n\nexports.type = exports.isNode ? 'node'\n  : exports.isMongo ? 'mongo'\n    : exports.isBrowser ? 'browser'\n      : 'unknown';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21xdWVyeUA1LjAuMC9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9lbnYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsY0FBYztBQUNkLDBCQUEwQixRQUFhO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxlcmljX1xcRGVza3RvcFxcc3luZXJneS1tYXRjaC1hcHBcXG5vZGVfbW9kdWxlc1xcLnBucG1cXG1xdWVyeUA1LjAuMFxcbm9kZV9tb2R1bGVzXFxtcXVlcnlcXGxpYlxcZW52LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5pc05vZGUgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgcHJvY2Vzc1xuICAgICAgICAgICAmJiAnb2JqZWN0JyA9PSB0eXBlb2YgbW9kdWxlXG4gICAgICAgICAgICYmICdvYmplY3QnID09IHR5cGVvZiBnbG9iYWxcbiAgICAgICAgICAgJiYgJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgQnVmZmVyXG4gICAgICAgICAgICYmIHByb2Nlc3MuYXJndjtcblxuZXhwb3J0cy5pc01vbmdvID0gIWV4cG9ydHMuaXNOb2RlXG4gICAgICAgICAgICYmICdmdW5jdGlvbicgPT0gdHlwZW9mIHByaW50anNvblxuICAgICAgICAgICAmJiAnZnVuY3Rpb24nID09IHR5cGVvZiBPYmplY3RJZFxuICAgICAgICAgICAmJiAnZnVuY3Rpb24nID09IHR5cGVvZiByc1xuICAgICAgICAgICAmJiAnZnVuY3Rpb24nID09IHR5cGVvZiBzaDtcblxuZXhwb3J0cy5pc0Jyb3dzZXIgPSAhZXhwb3J0cy5pc05vZGVcbiAgICAgICAgICAgICAgICAgJiYgIWV4cG9ydHMuaXNNb25nb1xuICAgICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2Ygd2luZG93O1xuXG5leHBvcnRzLnR5cGUgPSBleHBvcnRzLmlzTm9kZSA/ICdub2RlJ1xuICA6IGV4cG9ydHMuaXNNb25nbyA/ICdtb25nbydcbiAgICA6IGV4cG9ydHMuaXNCcm93c2VyID8gJ2Jyb3dzZXInXG4gICAgICA6ICd1bmtub3duJztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/env.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/mquery.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/mquery.js ***!
  \*******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n\n/**\n * Dependencies\n */\n\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ./utils */ \"(rsc)/../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/utils.js\");\nconst debug = __webpack_require__(/*! debug */ \"(rsc)/../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/index.js\")('mquery');\n\n/**\n * Query constructor used for building queries.\n *\n * #### Example:\n *\n *     var query = new Query({ name: 'mquery' });\n *     query.setOptions({ collection: moduleCollection })\n *     await query.where('age').gte(21).exec();\n *\n * @param {Object} [criteria] criteria for the query OR the collection instance to use\n * @param {Object} [options]\n * @api public\n */\n\nfunction Query(criteria, options) {\n  if (!(this instanceof Query))\n    return new Query(criteria, options);\n\n  const proto = this.constructor.prototype;\n\n  this.op = proto.op || undefined;\n\n  this.options = Object.assign({}, proto.options);\n\n  this._conditions = proto._conditions\n    ? utils.clone(proto._conditions)\n    : {};\n\n  this._fields = proto._fields\n    ? utils.clone(proto._fields)\n    : undefined;\n\n  this._updateDoc = proto._updateDoc\n    ? utils.clone(proto._updateDoc)\n    : undefined;\n\n  this._path = proto._path || undefined;\n  this._distinctDoc = proto._distinctDoc || undefined;\n  this._collection = proto._collection || undefined;\n  this._traceFunction = proto._traceFunction || undefined;\n\n  if (options) {\n    this.setOptions(options);\n  }\n\n  if (criteria) {\n    this.find(criteria);\n  }\n}\n\n/**\n * This is a parameter that the user can set which determines if mquery\n * uses $within or $geoWithin for queries. It defaults to true which\n * means $geoWithin will be used. If using MongoDB < 2.4 you should\n * set this to false.\n *\n * @api public\n * @property use$geoWithin\n */\n\nlet $withinCmd = '$geoWithin';\nObject.defineProperty(Query, 'use$geoWithin', {\n  get: function() { return $withinCmd == '$geoWithin'; },\n  set: function(v) {\n    if (true === v) {\n      // mongodb >= 2.4\n      $withinCmd = '$geoWithin';\n    } else {\n      $withinCmd = '$within';\n    }\n  }\n});\n\n/**\n * Converts this query to a constructor function with all arguments and options retained.\n *\n * #### Example:\n *\n *     // Create a query that will read documents with a \"video\" category from\n *     // `aCollection` on the primary node in the replica-set unless it is down,\n *     // in which case we'll read from a secondary node.\n *     var query = mquery({ category: 'video' })\n *     query.setOptions({ collection: aCollection, read: 'primaryPreferred' });\n *\n *     // create a constructor based off these settings\n *     var Video = query.toConstructor();\n *\n *     // Video is now a subclass of mquery() and works the same way but with the\n *     // default query parameters and options set.\n *\n *     // run a query with the previous settings but filter for movies with names\n *     // that start with \"Life\".\n *     Video().where({ name: /^Life/ }).exec(cb);\n *\n * @return {Query} new Query\n * @api public\n */\n\nQuery.prototype.toConstructor = function toConstructor() {\n  function CustomQuery(criteria, options) {\n    if (!(this instanceof CustomQuery))\n      return new CustomQuery(criteria, options);\n    Query.call(this, criteria, options);\n  }\n\n  utils.inherits(CustomQuery, Query);\n\n  // set inherited defaults\n  const p = CustomQuery.prototype;\n\n  p.options = {};\n  p.setOptions(this.options);\n\n  p.op = this.op;\n  p._conditions = utils.clone(this._conditions);\n  p._fields = utils.clone(this._fields);\n  p._updateDoc = utils.clone(this._updateDoc);\n  p._path = this._path;\n  p._distinctDoc = this._distinctDoc;\n  p._collection = this._collection;\n  p._traceFunction = this._traceFunction;\n\n  return CustomQuery;\n};\n\n/**\n * Sets query options.\n *\n * #### Options:\n *\n * - [tailable](http://www.mongodb.org/display/DOCS/Tailable+Cursors) *\n * - [sort](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsort(\\)%7D%7D) *\n * - [limit](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D) *\n * - [skip](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D) *\n * - [maxTime](http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS) *\n * - [batchSize](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D) *\n * - [comment](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment) *\n * - [hint](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint) *\n * - [slaveOk](http://docs.mongodb.org/manual/applications/replication/#read-preference) *\n * - [safe](http://www.mongodb.org/display/DOCS/getLastError+Command)\n * - collection the collection to query against\n *\n * _* denotes a query helper method is also available_\n *\n * @param {Object} options\n * @api public\n */\n\nQuery.prototype.setOptions = function(options) {\n  if (!(options && utils.isObject(options)))\n    return this;\n\n  // set arbitrary options\n  const methods = utils.keys(options);\n  let method;\n\n  for (let i = 0; i < methods.length; ++i) {\n    method = methods[i];\n\n    // use methods if exist (safer option manipulation)\n    if ('function' == typeof this[method]) {\n      const args = Array.isArray(options[method])\n        ? options[method]\n        : [options[method]];\n      this[method].apply(this, args);\n    } else {\n      this.options[method] = options[method];\n    }\n  }\n\n  return this;\n};\n\n/**\n * Sets this Querys collection.\n *\n * @param {Collection} coll\n * @return {Query} this\n */\n\nQuery.prototype.collection = function collection(coll) {\n  this._collection = new Query.Collection(coll);\n\n  return this;\n};\n\n/**\n * Adds a collation to this op (MongoDB 3.4 and up)\n *\n * #### Example:\n *\n *     query.find().collation({ locale: \"en_US\", strength: 1 })\n *\n * @param {Object} value\n * @return {Query} this\n * @see MongoDB docs https://docs.mongodb.com/manual/reference/method/cursor.collation/#cursor.collation\n * @api public\n */\n\nQuery.prototype.collation = function(value) {\n  this.options.collation = value;\n  return this;\n};\n\n/**\n * Specifies a `$where` condition\n *\n * Use `$where` when you need to select documents using a JavaScript expression.\n *\n * #### Example:\n *\n *     query.$where('this.comments.length > 10 || this.name.length > 5')\n *\n *     query.$where(function () {\n *       return this.comments.length > 10 || this.name.length > 5;\n *     })\n *\n * @param {String|Function} js javascript string or function\n * @return {Query} this\n * @memberOf Query\n * @method $where\n * @api public\n */\n\nQuery.prototype.$where = function(js) {\n  this._conditions.$where = js;\n  return this;\n};\n\n/**\n * Specifies a `path` for use with chaining.\n *\n * #### Example:\n *\n *     // instead of writing:\n *     await User.find({age: {$gte: 21, $lte: 65}});\n *\n *     // we can instead write:\n *     User.where('age').gte(21).lte(65);\n *\n *     // passing query conditions is permitted\n *     User.find().where({ name: 'vonderful' })\n *\n *     // chaining\n *     await User\n *       .where('age').gte(21).lte(65)\n *       .where('name', /^vonderful/i)\n *       .where('friends').slice(10)\n *       .exec()\n *\n * @param {String} [path]\n * @param {Object} [val]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.where = function() {\n  if (!arguments.length) return this;\n  if (!this.op) this.op = 'find';\n\n  const type = typeof arguments[0];\n\n  if ('string' == type) {\n    this._path = arguments[0];\n\n    if (2 === arguments.length) {\n      this._conditions[this._path] = arguments[1];\n    }\n\n    return this;\n  }\n\n  if ('object' == type && !Array.isArray(arguments[0])) {\n    return this.merge(arguments[0]);\n  }\n\n  throw new TypeError('path must be a string or object');\n};\n\n/**\n * Specifies the complementary comparison value for paths specified with `where()`\n *\n * #### Example:\n *\n *     User.where('age').equals(49);\n *\n *     // is the same as\n *\n *     User.where('age', 49);\n *\n * @param {Object} val\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.equals = function equals(val) {\n  this._ensurePath('equals');\n  const path = this._path;\n  this._conditions[path] = val;\n  return this;\n};\n\n/**\n * Specifies the complementary comparison value for paths specified with `where()`\n * This is alias of `equals`\n *\n * #### Example:\n *\n *     User.where('age').eq(49);\n *\n *     // is the same as\n *\n *     User.shere('age').equals(49);\n *\n *     // is the same as\n *\n *     User.where('age', 49);\n *\n * @param {Object} val\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.eq = function eq(val) {\n  this._ensurePath('eq');\n  const path = this._path;\n  this._conditions[path] = val;\n  return this;\n};\n\n/**\n * Specifies arguments for an `$or` condition.\n *\n * #### Example:\n *\n *     query.or([{ color: 'red' }, { status: 'emergency' }])\n *\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.or = function or(array) {\n  const or = this._conditions.$or || (this._conditions.$or = []);\n  if (!Array.isArray(array)) array = [array];\n  or.push.apply(or, array);\n  return this;\n};\n\n/**\n * Specifies arguments for a `$nor` condition.\n *\n * #### Example:\n *\n *     query.nor([{ color: 'green' }, { status: 'ok' }])\n *\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.nor = function nor(array) {\n  const nor = this._conditions.$nor || (this._conditions.$nor = []);\n  if (!Array.isArray(array)) array = [array];\n  nor.push.apply(nor, array);\n  return this;\n};\n\n/**\n * Specifies arguments for a `$and` condition.\n *\n * #### Example:\n *\n *     query.and([{ color: 'green' }, { status: 'ok' }])\n *\n * @see $and http://docs.mongodb.org/manual/reference/operator/and/\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.and = function and(array) {\n  const and = this._conditions.$and || (this._conditions.$and = []);\n  if (!Array.isArray(array)) array = [array];\n  and.push.apply(and, array);\n  return this;\n};\n\n/**\n * Specifies a $gt query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * #### Example:\n *\n *     Thing.find().where('age').gt(21)\n *\n *     // or\n *     Thing.find().gt('age', 21)\n *\n * @method gt\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $gte query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method gte\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $lt query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lt\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $lte query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lte\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $ne query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method ne\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies an $in query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method in\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies an $nin query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method nin\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies an $all query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method all\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $size query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method size\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $regex query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method regex\n * @memberOf Query\n * @param {String} [path]\n * @param {String|RegExp} val\n * @api public\n */\n\n/**\n * Specifies a $maxDistance query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method maxDistance\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/*!\n * gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance\n *\n *     Thing.where('type').nin(array)\n */\n\n'gt gte lt lte ne in nin all regex size maxDistance minDistance'.split(' ').forEach(function($conditional) {\n  Query.prototype[$conditional] = function() {\n    let path, val;\n\n    if (1 === arguments.length) {\n      this._ensurePath($conditional);\n      val = arguments[0];\n      path = this._path;\n    } else {\n      val = arguments[1];\n      path = arguments[0];\n    }\n\n    const conds = this._conditions[path] === null || typeof this._conditions[path] === 'object' ?\n      this._conditions[path] :\n      (this._conditions[path] = {});\n    conds['$' + $conditional] = val;\n    return this;\n  };\n});\n\n/**\n * Specifies a `$mod` condition\n *\n * @param {String} [path]\n * @param {Number} val\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.mod = function() {\n  let val, path;\n\n  if (1 === arguments.length) {\n    this._ensurePath('mod');\n    val = arguments[0];\n    path = this._path;\n  } else if (2 === arguments.length && !Array.isArray(arguments[1])) {\n    this._ensurePath('mod');\n    val = [arguments[0], arguments[1]];\n    path = this._path;\n  } else if (3 === arguments.length) {\n    val = [arguments[1], arguments[2]];\n    path = arguments[0];\n  } else {\n    val = arguments[1];\n    path = arguments[0];\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n  conds.$mod = val;\n  return this;\n};\n\n/**\n * Specifies an `$exists` condition\n *\n * #### Example:\n *\n *     // { name: { $exists: true }}\n *     Thing.where('name').exists()\n *     Thing.where('name').exists(true)\n *     Thing.find().exists('name')\n *\n *     // { name: { $exists: false }}\n *     Thing.where('name').exists(false);\n *     Thing.find().exists('name', false);\n *\n * @param {String} [path]\n * @param {Number} val\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.exists = function() {\n  let path, val;\n\n  if (0 === arguments.length) {\n    this._ensurePath('exists');\n    path = this._path;\n    val = true;\n  } else if (1 === arguments.length) {\n    if ('boolean' === typeof arguments[0]) {\n      this._ensurePath('exists');\n      path = this._path;\n      val = arguments[0];\n    } else {\n      path = arguments[0];\n      val = true;\n    }\n  } else if (2 === arguments.length) {\n    path = arguments[0];\n    val = arguments[1];\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n  conds.$exists = val;\n  return this;\n};\n\n/**\n * Specifies an `$elemMatch` condition\n *\n * #### Example:\n *\n *     query.elemMatch('comment', { author: 'autobot', votes: {$gte: 5}})\n *\n *     query.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5}})\n *\n *     query.elemMatch('comment', function (elem) {\n *       elem.where('author').equals('autobot');\n *       elem.where('votes').gte(5);\n *     })\n *\n *     query.where('comment').elemMatch(function (elem) {\n *       elem.where({ author: 'autobot' });\n *       elem.where('votes').gte(5);\n *     })\n *\n * @param {String|Object|Function} path\n * @param {Object|Function} criteria\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.elemMatch = function() {\n  if (null == arguments[0])\n    throw new TypeError('Invalid argument');\n\n  let fn, path, criteria;\n\n  if ('function' === typeof arguments[0]) {\n    this._ensurePath('elemMatch');\n    path = this._path;\n    fn = arguments[0];\n  } else if (utils.isObject(arguments[0])) {\n    this._ensurePath('elemMatch');\n    path = this._path;\n    criteria = arguments[0];\n  } else if ('function' === typeof arguments[1]) {\n    path = arguments[0];\n    fn = arguments[1];\n  } else if (arguments[1] && utils.isObject(arguments[1])) {\n    path = arguments[0];\n    criteria = arguments[1];\n  } else {\n    throw new TypeError('Invalid argument');\n  }\n\n  if (fn) {\n    criteria = new Query;\n    fn(criteria);\n    criteria = criteria._conditions;\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n  conds.$elemMatch = criteria;\n  return this;\n};\n\n// Spatial queries\n\n/**\n * Sugar for geo-spatial queries.\n *\n * #### Example:\n *\n *     query.within().box()\n *     query.within().circle()\n *     query.within().geometry()\n *\n *     query.where('loc').within({ center: [50,50], radius: 10, unique: true, spherical: true });\n *     query.where('loc').within({ box: [[40.73, -73.9], [40.7, -73.988]] });\n *     query.where('loc').within({ polygon: [[],[],[],[]] });\n *\n *     query.where('loc').within([], [], []) // polygon\n *     query.where('loc').within([], []) // box\n *     query.where('loc').within({ type: 'LineString', coordinates: [...] }); // geometry\n *\n * #### Note:\n *\n * Must be used after `where()`.\n *\n * @memberOf Query\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.within = function within() {\n  // opinionated, must be used after where\n  this._ensurePath('within');\n  this._geoComparison = $withinCmd;\n\n  if (0 === arguments.length) {\n    return this;\n  }\n\n  if (2 === arguments.length) {\n    return this.box.apply(this, arguments);\n  } else if (2 < arguments.length) {\n    return this.polygon.apply(this, arguments);\n  }\n\n  const area = arguments[0];\n\n  if (!area)\n    throw new TypeError('Invalid argument');\n\n  if (area.center)\n    return this.circle(area);\n\n  if (area.box)\n    return this.box.apply(this, area.box);\n\n  if (area.polygon)\n    return this.polygon.apply(this, area.polygon);\n\n  if (area.type && area.coordinates)\n    return this.geometry(area);\n\n  throw new TypeError('Invalid argument');\n};\n\n/**\n * Specifies a $box condition\n *\n * #### Example:\n *\n *     var lowerLeft = [40.73083, -73.99756]\n *     var upperRight= [40.741404,  -73.988135]\n *\n *     query.where('loc').within().box(lowerLeft, upperRight)\n *     query.box('loc', lowerLeft, upperRight )\n *\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @see Query#within #query_Query-within\n * @param {String} path\n * @param {Object} val\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.box = function() {\n  let path, box;\n\n  if (3 === arguments.length) {\n    // box('loc', [], [])\n    path = arguments[0];\n    box = [arguments[1], arguments[2]];\n  } else if (2 === arguments.length) {\n    // box([], [])\n    this._ensurePath('box');\n    path = this._path;\n    box = [arguments[0], arguments[1]];\n  } else {\n    throw new TypeError('Invalid argument');\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n  conds[this._geoComparison || $withinCmd] = { $box: box };\n  return this;\n};\n\n/**\n * Specifies a $polygon condition\n *\n * #### Example:\n *\n *     query.where('loc').within().polygon([10,20], [13, 25], [7,15])\n *     query.polygon('loc', [10,20], [13, 25], [7,15])\n *\n * @param {String|Array} [path]\n * @param {Array|Object} [val]\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */\n\nQuery.prototype.polygon = function() {\n  let val, path;\n\n  if ('string' == typeof arguments[0]) {\n    // polygon('loc', [],[],[])\n    val = Array.from(arguments);\n    path = val.shift();\n  } else {\n    // polygon([],[],[])\n    this._ensurePath('polygon');\n    path = this._path;\n    val = Array.from(arguments);\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n  conds[this._geoComparison || $withinCmd] = { $polygon: val };\n  return this;\n};\n\n/**\n * Specifies a $center or $centerSphere condition.\n *\n * #### Example:\n *\n *     var area = { center: [50, 50], radius: 10, unique: true }\n *     query.where('loc').within().circle(area)\n *     query.center('loc', area);\n *\n *     // for spherical calculations\n *     var area = { center: [50, 50], radius: 10, unique: true, spherical: true }\n *     query.where('loc').within().circle(area)\n *     query.center('loc', area);\n *\n * @param {String} [path]\n * @param {Object} area\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */\n\nQuery.prototype.circle = function() {\n  let path, val;\n\n  if (1 === arguments.length) {\n    this._ensurePath('circle');\n    path = this._path;\n    val = arguments[0];\n  } else if (2 === arguments.length) {\n    path = arguments[0];\n    val = arguments[1];\n  } else {\n    throw new TypeError('Invalid argument');\n  }\n\n  if (!('radius' in val && val.center))\n    throw new Error('center and radius are required');\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n\n  const type = val.spherical\n    ? '$centerSphere'\n    : '$center';\n\n  const wKey = this._geoComparison || $withinCmd;\n  conds[wKey] = {};\n  conds[wKey][type] = [val.center, val.radius];\n\n  if ('unique' in val)\n    conds[wKey].$uniqueDocs = !!val.unique;\n\n  return this;\n};\n\n/**\n * Specifies a `$near` or `$nearSphere` condition\n *\n * These operators return documents sorted by distance.\n *\n * #### Example:\n *\n *     query.where('loc').near({ center: [10, 10] });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5 });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5, spherical: true });\n *     query.near('loc', { center: [10, 10], maxDistance: 5 });\n *     query.near({ center: { type: 'Point', coordinates: [..] }})\n *     query.near().geometry({ type: 'Point', coordinates: [..] })\n *\n * @param {String} [path]\n * @param {Object} val\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */\n\nQuery.prototype.near = function near() {\n  let path, val;\n\n  this._geoComparison = '$near';\n\n  if (0 === arguments.length) {\n    return this;\n  } else if (1 === arguments.length) {\n    this._ensurePath('near');\n    path = this._path;\n    val = arguments[0];\n  } else if (2 === arguments.length) {\n    path = arguments[0];\n    val = arguments[1];\n  } else {\n    throw new TypeError('Invalid argument');\n  }\n\n  if (!val.center) {\n    throw new Error('center is required');\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n\n  const type = val.spherical\n    ? '$nearSphere'\n    : '$near';\n\n  // center could be a GeoJSON object or an Array\n  if (Array.isArray(val.center)) {\n    conds[type] = val.center;\n\n    const radius = 'maxDistance' in val\n      ? val.maxDistance\n      : null;\n\n    if (null != radius) {\n      conds.$maxDistance = radius;\n    }\n    if (null != val.minDistance) {\n      conds.$minDistance = val.minDistance;\n    }\n  } else {\n    // GeoJSON?\n    if (val.center.type != 'Point' || !Array.isArray(val.center.coordinates)) {\n      throw new Error(util.format('Invalid GeoJSON specified for %s', type));\n    }\n    conds[type] = { $geometry: val.center };\n\n    // MongoDB 2.6 insists on maxDistance being in $near / $nearSphere\n    if ('maxDistance' in val) {\n      conds[type]['$maxDistance'] = val.maxDistance;\n    }\n    if ('minDistance' in val) {\n      conds[type]['$minDistance'] = val.minDistance;\n    }\n  }\n\n  return this;\n};\n\n/**\n * Declares an intersects query for `geometry()`.\n *\n * #### Example:\n *\n *     query.where('path').intersects().geometry({\n *         type: 'LineString'\n *       , coordinates: [[180.0, 11.0], [180, 9.0]]\n *     })\n *\n *     query.where('path').intersects({\n *         type: 'LineString'\n *       , coordinates: [[180.0, 11.0], [180, 9.0]]\n *     })\n *\n * @param {Object} [arg]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.intersects = function intersects() {\n  // opinionated, must be used after where\n  this._ensurePath('intersects');\n\n  this._geoComparison = '$geoIntersects';\n\n  if (0 === arguments.length) {\n    return this;\n  }\n\n  const area = arguments[0];\n\n  if (null != area && area.type && area.coordinates)\n    return this.geometry(area);\n\n  throw new TypeError('Invalid argument');\n};\n\n/**\n * Specifies a `$geometry` condition\n *\n * #### Example:\n *\n *     var polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]\n *     query.where('loc').within().geometry({ type: 'Polygon', coordinates: polyA })\n *\n *     // or\n *     var polyB = [[ 0, 0 ], [ 1, 1 ]]\n *     query.where('loc').within().geometry({ type: 'LineString', coordinates: polyB })\n *\n *     // or\n *     var polyC = [ 0, 0 ]\n *     query.where('loc').within().geometry({ type: 'Point', coordinates: polyC })\n *\n *     // or\n *     query.where('loc').intersects().geometry({ type: 'Point', coordinates: polyC })\n *\n * #### Note:\n *\n * `geometry()` **must** come after either `intersects()` or `within()`.\n *\n * The `object` argument must contain `type` and `coordinates` properties.\n * - type {String}\n * - coordinates {Array}\n *\n * The most recent path passed to `where()` is used.\n *\n * @param {Object} object Must contain a `type` property which is a String and a `coordinates` property which is an Array. See the examples.\n * @return {Query} this\n * @see http://docs.mongodb.org/manual/release-notes/2.4/#new-geospatial-indexes-with-geojson-and-improved-spherical-geometry\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/\n * @api public\n */\n\nQuery.prototype.geometry = function geometry() {\n  if (!('$within' == this._geoComparison ||\n        '$geoWithin' == this._geoComparison ||\n        '$near' == this._geoComparison ||\n        '$geoIntersects' == this._geoComparison)) {\n    throw new Error('geometry() must come after `within()`, `intersects()`, or `near()');\n  }\n\n  let val, path;\n\n  if (1 === arguments.length) {\n    this._ensurePath('geometry');\n    path = this._path;\n    val = arguments[0];\n  } else {\n    throw new TypeError('Invalid argument');\n  }\n\n  if (!(val.type && Array.isArray(val.coordinates))) {\n    throw new TypeError('Invalid argument');\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n  conds[this._geoComparison] = { $geometry: val };\n\n  return this;\n};\n\n// end spatial\n\n/**\n * Specifies which document fields to include or exclude\n *\n * #### String syntax\n *\n * When passing a string, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included.\n *\n * #### Example:\n *\n *     // include a and b, exclude c\n *     query.select('a b -c');\n *\n *     // or you may use object notation, useful when\n *     // you have keys already prefixed with a \"-\"\n *     query.select({a: 1, b: 1, c: 0});\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Object|String} arg\n * @return {Query} this\n * @see SchemaType\n * @api public\n */\n\nQuery.prototype.select = function select() {\n  let arg = arguments[0];\n  if (!arg) return this;\n\n  if (arguments.length !== 1) {\n    throw new Error('Invalid select: select only takes 1 argument');\n  }\n\n  this._validate('select');\n\n  const fields = this._fields || (this._fields = {});\n  const type = typeof arg;\n  let i, len;\n\n  if (('string' == type || utils.isArgumentsObject(arg)) &&\n    'number' == typeof arg.length || Array.isArray(arg)) {\n    if ('string' == type)\n      arg = arg.split(/\\s+/);\n\n    for (i = 0, len = arg.length; i < len; ++i) {\n      let field = arg[i];\n      if (!field) continue;\n      const include = '-' == field[0] ? 0 : 1;\n      if (include === 0) field = field.substring(1);\n      fields[field] = include;\n    }\n\n    return this;\n  }\n\n  if (utils.isObject(arg)) {\n    const keys = utils.keys(arg);\n    for (i = 0; i < keys.length; ++i) {\n      fields[keys[i]] = arg[keys[i]];\n    }\n    return this;\n  }\n\n  throw new TypeError('Invalid select() argument. Must be string or object.');\n};\n\n/**\n * Specifies a $slice condition for a `path`\n *\n * #### Example:\n *\n *     query.slice('comments', 5)\n *     query.slice('comments', -5)\n *     query.slice('comments', [10, 5])\n *     query.where('comments').slice(5)\n *     query.where('comments').slice([-10, 5])\n *\n * @param {String} [path]\n * @param {Number} val number/range of elements to slice\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Retrieving+a+Subset+of+Fields#RetrievingaSubsetofFields-RetrievingaSubrangeofArrayElements\n * @api public\n */\n\nQuery.prototype.slice = function() {\n  if (0 === arguments.length)\n    return this;\n\n  this._validate('slice');\n\n  let path, val;\n\n  if (1 === arguments.length) {\n    const arg = arguments[0];\n    if (typeof arg === 'object' && !Array.isArray(arg)) {\n      const keys = Object.keys(arg);\n      const numKeys = keys.length;\n      for (let i = 0; i < numKeys; ++i) {\n        this.slice(keys[i], arg[keys[i]]);\n      }\n      return this;\n    }\n    this._ensurePath('slice');\n    path = this._path;\n    val = arguments[0];\n  } else if (2 === arguments.length) {\n    if ('number' === typeof arguments[0]) {\n      this._ensurePath('slice');\n      path = this._path;\n      val = [arguments[0], arguments[1]];\n    } else {\n      path = arguments[0];\n      val = arguments[1];\n    }\n  } else if (3 === arguments.length) {\n    path = arguments[0];\n    val = [arguments[1], arguments[2]];\n  }\n\n  const myFields = this._fields || (this._fields = {});\n  myFields[path] = { $slice: val };\n  return this;\n};\n\n/**\n * Sets the sort order\n *\n * If an object is passed, values allowed are 'asc', 'desc', 'ascending', 'descending', 1, and -1.\n *\n * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\n *\n * #### Example:\n *\n *     // these are equivalent\n *     query.sort({ field: 'asc', test: -1 });\n *     query.sort('field -test');\n *     query.sort([['field', 1], ['test', -1]]);\n *\n * #### Note:\n *\n *  - The array syntax `.sort([['field', 1], ['test', -1]])` can only be used with [mongodb driver >= 2.0.46](https://github.com/mongodb/node-mongodb-native/blob/2.1/HISTORY.md#2046-2015-10-15).\n *  - Cannot be used with `distinct()`\n *\n * @param {Object|String|Array} arg\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.sort = function(arg) {\n  if (!arg) return this;\n  let i, len, field;\n\n  this._validate('sort');\n\n  const type = typeof arg;\n\n  // .sort([['field', 1], ['test', -1]])\n  if (Array.isArray(arg)) {\n    len = arg.length;\n    for (i = 0; i < arg.length; ++i) {\n      if (!Array.isArray(arg[i])) {\n        throw new Error('Invalid sort() argument, must be array of arrays');\n      }\n      _pushArr(this.options, arg[i][0], arg[i][1]);\n    }\n    return this;\n  }\n\n  // .sort('field -test')\n  if (1 === arguments.length && 'string' == type) {\n    arg = arg.split(/\\s+/);\n    len = arg.length;\n    for (i = 0; i < len; ++i) {\n      field = arg[i];\n      if (!field) continue;\n      const ascend = '-' == field[0] ? -1 : 1;\n      if (ascend === -1) field = field.substring(1);\n      push(this.options, field, ascend);\n    }\n\n    return this;\n  }\n\n  // .sort({ field: 1, test: -1 })\n  if (utils.isObject(arg)) {\n    const keys = utils.keys(arg);\n    for (i = 0; i < keys.length; ++i) {\n      field = keys[i];\n      push(this.options, field, arg[field]);\n    }\n\n    return this;\n  }\n\n  if (typeof Map !== 'undefined' && arg instanceof Map) {\n    _pushMap(this.options, arg);\n    return this;\n  }\n  throw new TypeError('Invalid sort() argument. Must be a string, object, or array.');\n};\n\n/*!\n * @ignore\n */\n\nconst _validSortValue = {\n  1: 1,\n  '-1': -1,\n  asc: 1,\n  ascending: 1,\n  desc: -1,\n  descending: -1\n};\n\nfunction push(opts, field, value) {\n  if (Array.isArray(opts.sort)) {\n    throw new TypeError('Can\\'t mix sort syntaxes. Use either array or object:' +\n      '\\n- `.sort([[\\'field\\', 1], [\\'test\\', -1]])`' +\n      '\\n- `.sort({ field: 1, test: -1 })`');\n  }\n\n  let s;\n  if (value && value.$meta) {\n    s = opts.sort || (opts.sort = {});\n    s[field] = { $meta: value.$meta };\n    return;\n  }\n\n  s = opts.sort || (opts.sort = {});\n  let val = String(value || 1).toLowerCase();\n  val = _validSortValue[val];\n  if (!val) throw new TypeError('Invalid sort value: { ' + field + ': ' + value + ' }');\n\n  s[field] = val;\n}\n\nfunction _pushArr(opts, field, value) {\n  opts.sort = opts.sort || [];\n  if (!Array.isArray(opts.sort)) {\n    throw new TypeError('Can\\'t mix sort syntaxes. Use either array or object:' +\n      '\\n- `.sort([[\\'field\\', 1], [\\'test\\', -1]])`' +\n      '\\n- `.sort({ field: 1, test: -1 })`');\n  }\n\n  let val = String(value || 1).toLowerCase();\n  val = _validSortValue[val];\n  if (!val) throw new TypeError('Invalid sort value: [ ' + field + ', ' + value + ' ]');\n\n  opts.sort.push([field, val]);\n}\n\nfunction _pushMap(opts, map) {\n  opts.sort = opts.sort || new Map();\n  if (!(opts.sort instanceof Map)) {\n    throw new TypeError('Can\\'t mix sort syntaxes. Use either array or ' +\n      'object or map consistently');\n  }\n  map.forEach(function(value, key) {\n    let val = String(value || 1).toLowerCase();\n    val = _validSortValue[val];\n    if (!val) throw new TypeError('Invalid sort value: < ' + key + ': ' + value + ' >');\n\n    opts.sort.set(key, val);\n  });\n}\n\n\n/**\n * Specifies the limit option.\n *\n * #### Example:\n *\n *     query.limit(20)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method limit\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D\n * @api public\n */\n/**\n * Specifies the skip option.\n *\n * #### Example:\n *\n *     query.skip(100).limit(20)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method skip\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D\n * @api public\n */\n/**\n * Specifies the batchSize option.\n *\n * #### Example:\n *\n *     query.batchSize(100)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method batchSize\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D\n * @api public\n */\n/**\n * Specifies the `comment` option.\n *\n * #### Example:\n *\n *     query.comment('login query')\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method comment\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment\n * @api public\n */\n\n/*!\n * limit, skip, batchSize, comment\n *\n * Sets these associated options.\n *\n *     query.comment('feed query');\n */\n\n['limit', 'skip', 'batchSize', 'comment'].forEach(function(method) {\n  Query.prototype[method] = function(v) {\n    this._validate(method);\n    this.options[method] = v;\n    return this;\n  };\n});\n\n/**\n * Specifies the maxTimeMS option.\n *\n * #### Example:\n *\n *     query.maxTime(100)\n *     query.maxTimeMS(100)\n *\n * @method maxTime\n * @memberOf Query\n * @param {Number} ms\n * @see mongodb http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS\n * @api public\n */\n\nQuery.prototype.maxTime = Query.prototype.maxTimeMS = function(ms) {\n  this._validate('maxTime');\n  this.options.maxTimeMS = ms;\n  return this;\n};\n\n/**\n * Sets query hints.\n *\n * #### Example:\n *\n *     query.hint({ indexA: 1, indexB: -1});\n *     query.hint('indexA_1_indexB_1');\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Object|string} val a hint object or the index name\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint\n * @api public\n */\n\nQuery.prototype.hint = function() {\n  if (0 === arguments.length) return this;\n\n  this._validate('hint');\n\n  const arg = arguments[0];\n  if (utils.isObject(arg)) {\n    const hint = this.options.hint || (this.options.hint = {});\n\n    // must keep object keys in order so don't use Object.keys()\n    for (const k in arg) {\n      hint[k] = arg[k];\n    }\n\n    return this;\n  }\n  if (typeof arg === 'string') {\n    this.options.hint = arg;\n    return this;\n  }\n\n  throw new TypeError('Invalid hint. ' + arg);\n};\n\n/**\n * Requests acknowledgement that this operation has been persisted to MongoDB's\n * on-disk journal.\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the `j` value if it is specified in writeConcern options\n *\n * #### Example:\n *\n *     mquery().w(2).j(true).wtimeout(2000);\n *\n * @method j\n * @memberOf Query\n * @instance\n * @param {boolean} val\n * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#j-option\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.j = function j(val) {\n  this.options.j = val;\n  return this;\n};\n\n/**\n * Sets the slaveOk option. _Deprecated_ in MongoDB 2.2 in favor of read preferences.\n *\n * #### Example:\n *\n *     query.slaveOk() // true\n *     query.slaveOk(true)\n *     query.slaveOk(false)\n *\n * @deprecated use read() preferences instead if on mongodb >= 2.2\n * @param {Boolean} v defaults to true\n * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference\n * @see read()\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.slaveOk = function(v) {\n  this.options.slaveOk = arguments.length ? !!v : true;\n  return this;\n};\n\n/**\n * Sets the readPreference option for the query.\n *\n * #### Example:\n *\n *     new Query().read('primary')\n *     new Query().read('p')  // same as primary\n *\n *     new Query().read('primaryPreferred')\n *     new Query().read('pp') // same as primaryPreferred\n *\n *     new Query().read('secondary')\n *     new Query().read('s')  // same as secondary\n *\n *     new Query().read('secondaryPreferred')\n *     new Query().read('sp') // same as secondaryPreferred\n *\n *     new Query().read('nearest')\n *     new Query().read('n')  // same as nearest\n *\n *     // you can also use mongodb.ReadPreference class to also specify tags\n *     new Query().read(mongodb.ReadPreference('secondary', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }]))\n *\n *     new Query().setReadPreference('primary') // alias of .read()\n *\n * #### Preferences:\n *\n *     primary - (default)  Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.\n *     secondary            Read from secondary if available, otherwise error.\n *     primaryPreferred     Read from primary if available, otherwise a secondary.\n *     secondaryPreferred   Read from a secondary if available, otherwise read from the primary.\n *     nearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.\n *\n * Aliases\n *\n *     p   primary\n *     pp  primaryPreferred\n *     s   secondary\n *     sp  secondaryPreferred\n *     n   nearest\n *\n * Read more about how to use read preferences [here](http://docs.mongodb.org/manual/applications/replication/#read-preference) and [here](http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences).\n *\n * @param {String|ReadPreference} pref one of the listed preference options or their aliases\n * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference\n * @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.read = Query.prototype.setReadPreference = function(pref) {\n  if (arguments.length > 1 && !Query.prototype.read.deprecationWarningIssued) {\n    console.error('Deprecation warning: \\'tags\\' argument is not supported anymore in Query.read() method. Please use mongodb.ReadPreference object instead.');\n    Query.prototype.read.deprecationWarningIssued = true;\n  }\n  this.options.readPreference = utils.readPref(pref);\n  return this;\n};\n\n/**\n * Sets the readConcern option for the query.\n *\n * #### Example:\n *\n *     new Query().readConcern('local')\n *     new Query().readConcern('l')  // same as local\n *\n *     new Query().readConcern('available')\n *     new Query().readConcern('a')  // same as available\n *\n *     new Query().readConcern('majority')\n *     new Query().readConcern('m')  // same as majority\n *\n *     new Query().readConcern('linearizable')\n *     new Query().readConcern('lz') // same as linearizable\n *\n *     new Query().readConcern('snapshot')\n *     new Query().readConcern('s')  // same as snapshot\n *\n *     new Query().r('s') // r is alias of readConcern\n *\n *\n * #### Read Concern Level:\n *\n *     local         MongoDB 3.2+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\n *     available     MongoDB 3.6+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\n *     majority      MongoDB 3.2+ The query returns the data that has been acknowledged by a majority of the replica set members. The documents returned by the read operation are durable, even in the event of failure.\n *     linearizable  MongoDB 3.4+ The query returns data that reflects all successful majority-acknowledged writes that completed prior to the start of the read operation. The query may wait for concurrently executing writes to propagate to a majority of replica set members before returning results.\n *     snapshot      MongoDB 4.0+ Only available for operations within multi-document transactions. Upon transaction commit with write concern \"majority\", the transaction operations are guaranteed to have read from a snapshot of majority-committed data.\n *\n * Aliases\n *\n *     l   local\n *     a   available\n *     m   majority\n *     lz  linearizable\n *     s   snapshot\n *\n * Read more about how to use read concern [here](https://docs.mongodb.com/manual/reference/read-concern/).\n *\n * @param {String} level one of the listed read concern level or their aliases\n * @see mongodb https://docs.mongodb.com/manual/reference/read-concern/\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.readConcern = Query.prototype.r = function(level) {\n  this.options.readConcern = utils.readConcern(level);\n  return this;\n};\n\n/**\n * Sets tailable option.\n *\n * #### Example:\n *\n *     query.tailable() <== true\n *     query.tailable(true)\n *     query.tailable(false)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Boolean} v defaults to true\n * @see mongodb http://www.mongodb.org/display/DOCS/Tailable+Cursors\n * @api public\n */\n\nQuery.prototype.tailable = function() {\n  this._validate('tailable');\n\n  this.options.tailable = arguments.length\n    ? !!arguments[0]\n    : true;\n\n  return this;\n};\n\n/**\n * Sets the specified number of `mongod` servers, or tag set of `mongod` servers,\n * that must acknowledge this write before this write is considered successful.\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the `w` value if it is specified in writeConcern options\n *\n * #### Example:\n *\n *     mquery().writeConcern(0)\n *     mquery().writeConcern(1)\n *     mquery().writeConcern({ w: 1, j: true, wtimeout: 2000 })\n *     mquery().writeConcern('majority')\n *     mquery().writeConcern('m') // same as majority\n *     mquery().writeConcern('tagSetName') // if the tag set is 'm', use .writeConcern({ w: 'm' }) instead\n *     mquery().w(1) // w is alias of writeConcern\n *\n * @method writeConcern\n * @memberOf Query\n * @instance\n * @param {String|number|object} concern 0 for fire-and-forget, 1 for acknowledged by one server, 'majority' for majority of the replica set, or [any of the more advanced options](https://docs.mongodb.com/manual/reference/write-concern/#w-option).\n * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#w-option\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.writeConcern = Query.prototype.w = function writeConcern(concern) {\n  if ('object' === typeof concern) {\n    if ('undefined' !== typeof concern.j) this.options.j = concern.j;\n    if ('undefined' !== typeof concern.w) this.options.w = concern.w;\n    if ('undefined' !== typeof concern.wtimeout) this.options.wtimeout = concern.wtimeout;\n  } else {\n    this.options.w = 'm' === concern ? 'majority' : concern;\n  }\n  return this;\n};\n\n/**\n * Specifies a time limit, in milliseconds, for the write concern.\n * If `ms > 1`, it is maximum amount of time to wait for this write\n * to propagate through the replica set before this operation fails.\n * The default is `0`, which means no timeout.\n *\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to `wtimeout` value if it is specified in writeConcern\n *\n * #### Example:\n *\n *     mquery().w(2).j(true).wtimeout(2000)\n *\n * @method wtimeout\n * @memberOf Query\n * @instance\n * @param {number} ms number of milliseconds to wait\n * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#wtimeout\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.wtimeout = Query.prototype.wTimeout = function wtimeout(ms) {\n  this.options.wtimeout = ms;\n  return this;\n};\n\n/**\n * Merges another Query or conditions object into this one.\n *\n * When a Query is passed, conditions, field selection and options are merged.\n *\n * @param {Query|Object} source\n * @return {Query} this\n */\n\nQuery.prototype.merge = function(source) {\n  if (!source)\n    return this;\n\n  if (!Query.canMerge(source))\n    throw new TypeError('Invalid argument. Expected instanceof mquery or plain object');\n\n  if (source instanceof Query) {\n    // if source has a feature, apply it to ourselves\n\n    if (source._conditions) {\n      utils.merge(this._conditions, source._conditions);\n    }\n\n    if (source._fields) {\n      this._fields || (this._fields = {});\n      utils.merge(this._fields, source._fields);\n    }\n\n    if (source.options) {\n      this.options || (this.options = {});\n      utils.merge(this.options, source.options);\n    }\n\n    if (source._updateDoc) {\n      this._updateDoc || (this._updateDoc = {});\n      utils.mergeClone(this._updateDoc, source._updateDoc);\n    }\n\n    if (source._distinctDoc) {\n      this._distinctDoc = source._distinctDoc;\n    }\n\n    return this;\n  }\n\n  // plain object\n  utils.merge(this._conditions, source);\n\n  return this;\n};\n\n/**\n * Finds documents.\n *\n * #### Example:\n *\n *     query.find()\n *     await query.find()\n *     await query.find({ name: 'Burning Lights' })\n *\n * @param {Object} [criteria] mongodb selector\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.find = function(criteria) {\n  this.op = 'find';\n\n  if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  return this;\n};\n\n/**\n * Executes a `find` Query\n * @returns the result\n */\nQuery.prototype._find = async function _find() {\n  const conds = this._conditions;\n  const options = this._optionsForExec();\n\n  if (this.$useProjection) {\n    options.projection = this._fieldsForExec();\n  } else {\n    options.fields = this._fieldsForExec();\n  }\n\n  debug('_find', this._collection.collectionName, conds, options);\n\n  return this._collection.find(conds, options);\n};\n\n/**\n * Returns the query cursor\n *\n * #### Examples:\n *\n *     query.find().cursor();\n *     query.cursor({ name: 'Burning Lights' });\n *\n * @param {Object} [criteria] mongodb selector\n * @return {Object} cursor\n * @api public\n */\n\nQuery.prototype.cursor = function cursor(criteria) {\n  if (this.op) {\n    if (this.op !== 'find') {\n      throw new TypeError('.cursor only support .find method');\n    }\n  } else {\n    this.find(criteria);\n  }\n\n  const conds = this._conditions;\n  const options = this._optionsForExec();\n\n  if (this.$useProjection) {\n    options.projection = this._fieldsForExec();\n  } else {\n    options.fields = this._fieldsForExec();\n  }\n\n  debug('findCursor', this._collection.collectionName, conds, options);\n  return this._collection.findCursor(conds, options);\n};\n\n/**\n * Executes the query as a findOne() operation.\n *\n * #### Example:\n *\n *     query.findOne().where('name', /^Burning/);\n *\n *     query.findOne({ name: /^Burning/ })\n *\n *     await query.findOne({ name: /^Burning/ }); // executes\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.findOne = function(criteria) {\n  this.op = 'findOne';\n\n  if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  return this;\n};\n\n/**\n * Executes a `findOne` Query\n * @returns the results\n */\nQuery.prototype._findOne = async function _findOne() {\n  const conds = this._conditions;\n  const options = this._optionsForExec();\n\n  if (this.$useProjection) {\n    options.projection = this._fieldsForExec();\n  } else {\n    options.fields = this._fieldsForExec();\n  }\n\n  debug('findOne', this._collection.collectionName, conds, options);\n\n  return this._collection.findOne(conds, options);\n};\n\n/**\n * Exectues the query as a count() operation.\n *\n * #### Example:\n *\n *     query.count().where('color', 'black').exec();\n *\n *     query.count({ color: 'black' })\n *\n *     await query.count({ color: 'black' });\n *\n *     const doc = await query.where('color', 'black').count();\n *     console.log('there are %d kittens', count);\n *\n * @param {Object} [criteria] mongodb selector\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Count\n * @api public\n */\n\nQuery.prototype.count = function(criteria) {\n  this.op = 'count';\n  this._validate();\n\n  if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  return this;\n};\n\n/**\n * Executes a `count` Query\n * @returns the results\n */\nQuery.prototype._count = async function _count() {\n  const conds = this._conditions,\n      options = this._optionsForExec();\n\n  debug('count', this._collection.collectionName, conds, options);\n\n  return this._collection.count(conds, options);\n};\n\n/**\n * Declares or executes a distinct() operation.\n *\n * #### Example:\n *\n *     await distinct(criteria, field)\n *     distinct(criteria, field)\n *     await distinct(field)\n *     distinct(field)\n *     await distinct()\n *     distinct()\n *\n * @param {Object|Query} [criteria]\n * @param {String} [field]\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Distinct\n * @api public\n */\n\nQuery.prototype.distinct = function(criteria, field) {\n  this.op = 'distinct';\n  this._validate();\n\n  if (!field && typeof criteria === 'string') {\n    field = criteria;\n    criteria = undefined;\n  }\n\n  if ('string' == typeof field) {\n    this._distinctDoc = field;\n  }\n\n  if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  return this;\n};\n\n/**\n * Executes a `distinct` Query\n * @returns the results\n */\nQuery.prototype._distinct = async function _distinct() {\n  if (!this._distinctDoc) {\n    throw new Error('No value for `distinct` has been declared');\n  }\n\n  const conds = this._conditions,\n      options = this._optionsForExec();\n\n  debug('distinct', this._collection.collectionName, conds, options);\n\n  return this._collection.distinct(this._distinctDoc, conds, options);\n};\n\n/**\n * Declare and/or execute this query as an `updateMany()` operation. This function will update _all_ documents that match\n * `criteria`, rather than just the first one.\n *\n * _All paths passed that are not $atomic operations will become $set ops._\n *\n * #### Example:\n *\n *     // Update every document whose `title` contains 'test'\n *     mquery().updateMany({ title: /test/ }, { year: 2017 })\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.updateMany = function updateMany(criteria, doc, options) {\n  if (arguments.length === 1) {\n    doc = criteria;\n    criteria = options = undefined;\n  }\n\n  return _update(this, 'updateMany', criteria, doc, options);\n};\n\n/**\n * Executes a `updateMany` Query\n * @returns the results\n */\nQuery.prototype._updateMany = async function() {\n  return _updateExec(this, 'updateMany');\n};\n\n/**\n * Declare and/or execute this query as an `updateOne()` operation. This function will _always_ update just one document,\n * regardless of the `multi` option.\n *\n * _All paths passed that are not $atomic operations will become $set ops._\n *\n * #### Example:\n *\n *     // Update the first document whose `title` contains 'test'\n *     mquery().updateMany({ title: /test/ }, { year: 2017 })\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.updateOne = function updateOne(criteria, doc, options) {\n  if (arguments.length === 1) {\n    doc = criteria;\n    criteria = options = undefined;\n  }\n\n  return _update(this, 'updateOne', criteria, doc, options);\n};\n\n/**\n * Executes a `updateOne` Query\n * @returns the results\n */\nQuery.prototype._updateOne = async function() {\n  return _updateExec(this, 'updateOne');\n};\n\n/**\n * Declare and/or execute this query as an `replaceOne()` operation. Similar\n * to `updateOne()`, except `replaceOne()` is not allowed to use atomic\n * modifiers (`$set`, `$push`, etc.). Calling `replaceOne()` will always\n * replace the existing doc.\n *\n * #### Example:\n *\n *     // Replace the document with `_id` 1 with `{ _id: 1, year: 2017 }`\n *     mquery().replaceOne({ _id: 1 }, { year: 2017 })\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.replaceOne = function replaceOne(criteria, doc, options) {\n  if (arguments.length === 1) {\n    doc = criteria;\n    criteria = options = undefined;\n  }\n\n  this.setOptions({ overwrite: true });\n  return _update(this, 'replaceOne', criteria, doc, options);\n};\n\n/**\n * Executes a `replaceOne` Query\n * @returns the results\n */\nQuery.prototype._replaceOne = async function() {\n  return _updateExec(this, 'replaceOne');\n};\n\n/*!\n * Internal helper for updateMany, updateOne\n */\n\nfunction _update(query, op, criteria, doc, options) {\n  query.op = op;\n\n  if (Query.canMerge(criteria)) {\n    query.merge(criteria);\n  }\n\n  if (doc) {\n    query._mergeUpdate(doc);\n  }\n\n  if (utils.isObject(options)) {\n    // { overwrite: true }\n    query.setOptions(options);\n  }\n\n  return query;\n}\n\n/**\n * Helper for de-duplicating \"update*\" functions\n * @param {Query} query The Query Object (replacement for \"this\")\n * @param {String} op The Operation to be done\n * @returns the results\n */\nasync function _updateExec(query, op) {\n  const options = query._optionsForExec();\n\n  const criteria = query._conditions;\n  const doc = query._updateForExec();\n\n  debug('update', query._collection.collectionName, criteria, doc, options);\n\n  return query._collection[op](criteria, doc, options);\n}\n\n/**\n * Declare and/or execute this query as a `deleteOne()` operation.\n *\n * #### Example:\n *\n *     await mquery(collection).deleteOne({ artist: 'Anne Murray' })\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.deleteOne = function(criteria) {\n  this.op = 'deleteOne';\n\n  if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  return this;\n};\n\n/**\n * Executes a `deleteOne` Query\n * @returns the results\n */\nQuery.prototype._deleteOne = async function() {\n  const options = this._optionsForExec();\n  delete options.justOne;\n\n  const conds = this._conditions;\n\n  debug('deleteOne', this._collection.collectionName, conds, options);\n\n  return this._collection.deleteOne(conds, options);\n};\n\n/**\n * Declare and/or execute this query as a `deleteMany()` operation. Always deletes\n * _every_ document that matches `criteria`.\n *\n * #### Example:\n *\n *     await mquery(collection).deleteMany({ artist: 'Anne Murray' })\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.deleteMany = function(criteria) {\n  this.op = 'deleteMany';\n\n  if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  return this;\n};\n\n/**\n * Executes a `deleteMany` Query\n * @returns the results\n */\nQuery.prototype._deleteMany = async function() {\n  const options = this._optionsForExec();\n  delete options.justOne;\n\n  const conds = this._conditions;\n\n  debug('deleteOne', this._collection.collectionName, conds, options);\n\n  return this._collection.deleteMany(conds, options);\n};\n\n/**\n * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) update command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any).\n *\n * #### Available options\n *\n * - `new`: bool - true to return the modified document rather than the original. defaults to true\n * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n *\n * #### Examples:\n *\n *     await query.findOneAndUpdate(conditions, update, options) // executes\n *     query.findOneAndUpdate(conditions, update, options)  // returns Query\n *     await query.findOneAndUpdate(conditions, update) // executes\n *     query.findOneAndUpdate(conditions, update)           // returns Query\n *     await query.findOneAndUpdate(update)             // returns Query\n *     query.findOneAndUpdate(update)                       // returns Query\n *     await query.findOneAndUpdate()                     // executes\n *     query.findOneAndUpdate()                             // returns Query\n *\n * @param {Object|Query} [query]\n * @param {Object} [doc]\n * @param {Object} [options]\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.findOneAndUpdate = function(criteria, doc, options) {\n  this.op = 'findOneAndUpdate';\n  this._validate();\n\n  if (arguments.length === 1) {\n    doc = criteria;\n    criteria = options = undefined;\n  }\n\n  if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  // apply doc\n  if (doc) {\n    this._mergeUpdate(doc);\n  }\n\n  options && this.setOptions(options);\n\n  return this;\n};\n\n/**\n * Executes a `findOneAndUpdate` Query\n * @returns the results\n */\nQuery.prototype._findOneAndUpdate = async function() {\n  const conds = this._conditions;\n  const update = this._updateForExec();\n  const options = this._optionsForExec();\n\n  return this._collection.findOneAndUpdate(conds, update, options);\n};\n\n/**\n * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) remove command.\n *\n * Finds a matching document, removes it, returning the found document (if any).\n *\n * #### Available options\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n *\n * #### Examples:\n *\n *     await A.where().findOneAndRemove(conditions, options) // executes\n *     A.where().findOneAndRemove(conditions, options)  // return Query\n *     await A.where().findOneAndRemove(conditions) // executes\n *     A.where().findOneAndRemove(conditions) // returns Query\n *     await A.where().findOneAndRemove()   // executes\n *     A.where().findOneAndRemove()           // returns Query\n *     A.where().findOneAndDelete()           // alias of .findOneAndRemove()\n *\n * @param {Object} [conditions]\n * @param {Object} [options]\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @api public\n */\n\nQuery.prototype.findOneAndRemove = Query.prototype.findOneAndDelete = function(conditions, options) {\n  this.op = 'findOneAndRemove';\n  this._validate();\n\n  // apply conditions\n  if (Query.canMerge(conditions)) {\n    this.merge(conditions);\n  }\n\n  // apply options\n  options && this.setOptions(options);\n\n  return this;\n};\n\n/**\n * Executes a `findOneAndRemove` Query\n * @returns the results\n */\nQuery.prototype._findOneAndRemove = async function() {\n  const options = this._optionsForExec();\n  const conds = this._conditions;\n\n  return this._collection.findOneAndDelete(conds, options);\n};\n\n/**\n * Add trace function that gets called when the query is executed.\n * The function will be called with (method, queryInfo, query) and\n * should return a callback function which will be called\n * with (err, result, millis) when the query is complete.\n *\n * queryInfo is an object containing: {\n *   collectionName: <name of the collection>,\n *   conditions: <query criteria>,\n *   options: <comment, fields, readPreference, etc>,\n *   doc: [document to update, if applicable]\n * }\n *\n * NOTE: Does not trace stream queries.\n *\n * @param {Function} traceFunction\n * @return {Query} this\n * @api public\n */\nQuery.prototype.setTraceFunction = function(traceFunction) {\n  this._traceFunction = traceFunction;\n  return this;\n};\n\n/**\n * Executes the query\n *\n * #### Examples:\n *\n *     query.exec();\n *     await query.exec();\n *     query.exec('update');\n *     await query.exec('find');\n *\n * @param {String|Function} [operation]\n * @api public\n */\n\nQuery.prototype.exec = async function exec(op) {\n  if (typeof op === 'string') {\n    this.op = op;\n  }\n\n  assert.ok(this.op, 'Missing query type: (find, etc)');\n\n  const fnName = '_' + this.op;\n\n  // better error, because default would list it as \"this[fnName] is not a function\"\n  if (typeof this[fnName] !== 'function') {\n    throw new TypeError(`this[${fnName}] is not a function`);\n  }\n\n  return this[fnName]();\n};\n\n/**\n * Executes the query returning a `Promise` which will be\n * resolved with either the doc(s) or rejected with the error.\n *\n * @param {Function} [resolve]\n * @param {Function} [reject]\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.then = async function(res, rej) {\n  return this.exec().then(res, rej);\n};\n\n/**\n * Returns a cursor for the given `find` query.\n *\n * @throws Error if operation is not a find\n * @returns {Cursor} MongoDB driver cursor\n */\n\nQuery.prototype.cursor = function() {\n  if ('find' != this.op)\n    throw new Error('cursor() is only available for find');\n\n  const conds = this._conditions;\n\n  const options = this._optionsForExec();\n  if (this.$useProjection) {\n    options.projection = this._fieldsForExec();\n  } else {\n    options.fields = this._fieldsForExec();\n  }\n\n  debug('cursor', this._collection.collectionName, conds, options);\n\n  return this._collection.findCursor(conds, options);\n};\n\n/**\n * Determines if field selection has been made.\n *\n * @return {Boolean}\n * @api public\n */\n\nQuery.prototype.selected = function selected() {\n  return !!(this._fields && Object.keys(this._fields).length > 0);\n};\n\n/**\n * Determines if inclusive field selection has been made.\n *\n *     query.selectedInclusively() // false\n *     query.select('name')\n *     query.selectedInclusively() // true\n *     query.selectedExlusively() // false\n *\n * @returns {Boolean}\n */\n\nQuery.prototype.selectedInclusively = function selectedInclusively() {\n  if (!this._fields) return false;\n\n  const keys = Object.keys(this._fields);\n  if (0 === keys.length) return false;\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (0 === this._fields[key]) return false;\n    if (this._fields[key] &&\n        typeof this._fields[key] === 'object' &&\n        this._fields[key].$meta) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Determines if exclusive field selection has been made.\n *\n *     query.selectedExlusively() // false\n *     query.select('-name')\n *     query.selectedExlusively() // true\n *     query.selectedInclusively() // false\n *\n * @returns {Boolean}\n */\n\nQuery.prototype.selectedExclusively = function selectedExclusively() {\n  if (!this._fields) return false;\n\n  const keys = Object.keys(this._fields);\n  if (0 === keys.length) return false;\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (0 === this._fields[key]) return true;\n  }\n\n  return false;\n};\n\n/**\n * Merges `doc` with the current update object.\n *\n * @param {Object} doc\n */\n\nQuery.prototype._mergeUpdate = function(doc) {\n  if (!this._updateDoc) this._updateDoc = {};\n  if (doc instanceof Query) {\n    if (doc._updateDoc) {\n      utils.mergeClone(this._updateDoc, doc._updateDoc);\n    }\n  } else {\n    utils.mergeClone(this._updateDoc, doc);\n  }\n};\n\n/**\n * Returns default options.\n *\n * @return {Object}\n * @api private\n */\n\nQuery.prototype._optionsForExec = function() {\n  const options = utils.clone(this.options);\n  return options;\n};\n\n/**\n * Returns fields selection for this query.\n *\n * @return {Object}\n * @api private\n */\n\nQuery.prototype._fieldsForExec = function() {\n  return utils.clone(this._fields);\n};\n\n/**\n * Return an update document with corrected $set operations.\n *\n * @api private\n */\n\nQuery.prototype._updateForExec = function() {\n  const update = utils.clone(this._updateDoc);\n  const ops = utils.keys(update);\n  const ret = {};\n\n  for (const op of ops) {\n    if (this.options.overwrite) {\n      ret[op] = update[op];\n      continue;\n    }\n\n    if ('$' !== op[0]) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (update.$set) {\n          ret.$set = update.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = update[op];\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if ('$set' === op) {\n      if (!ret.$set) {\n        ret[op] = update[op];\n      }\n    } else {\n      ret[op] = update[op];\n    }\n  }\n\n  this._compiledUpdate = ret;\n  return ret;\n};\n\n/**\n * Make sure _path is set.\n *\n * @parmam {String} method\n */\n\nQuery.prototype._ensurePath = function(method) {\n  if (!this._path) {\n    const msg = method + '() must be used after where() '\n                     + 'when called with these arguments';\n    throw new Error(msg);\n  }\n};\n\n/*!\n * Permissions\n */\n\nQuery.permissions = __webpack_require__(/*! ./permissions */ \"(rsc)/../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/permissions.js\");\n\nQuery._isPermitted = function(a, b) {\n  const denied = Query.permissions[b];\n  if (!denied) return true;\n  return true !== denied[a];\n};\n\nQuery.prototype._validate = function(action) {\n  let fail;\n  let validator;\n\n  if (undefined === action) {\n\n    validator = Query.permissions[this.op];\n    if ('function' != typeof validator) return true;\n\n    fail = validator(this);\n\n  } else if (!Query._isPermitted(action, this.op)) {\n    fail = action;\n  }\n\n  if (fail) {\n    throw new Error(fail + ' cannot be used with ' + this.op);\n  }\n};\n\n/**\n * Determines if `conds` can be merged using `mquery().merge()`\n *\n * @param {Object} conds\n * @return {Boolean}\n */\n\nQuery.canMerge = function(conds) {\n  return conds instanceof Query || utils.isObject(conds);\n};\n\n/**\n * Set a trace function that will get called whenever a\n * query is executed.\n *\n * See `setTraceFunction()` for details.\n *\n * @param {Object} conds\n * @return {Boolean}\n */\nQuery.setGlobalTraceFunction = function(traceFunction) {\n  Query.traceFunction = traceFunction;\n};\n\n/*!\n * Exports.\n */\n\nQuery.utils = utils;\nQuery.env = __webpack_require__(/*! ./env */ \"(rsc)/../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/env.js\");\nQuery.Collection = __webpack_require__(/*! ./collection */ \"(rsc)/../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/index.js\");\nQuery.BaseCollection = __webpack_require__(/*! ./collection/collection */ \"(rsc)/../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/collection.js\");\nmodule.exports = exports = Query;\n\n// TODO\n// test utils\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21xdWVyeUA1LjAuMC9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9tcXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsY0FBYyxtQkFBTyxDQUFDLDZGQUFTO0FBQy9CLGNBQWMsbUJBQU8sQ0FBQyx5RkFBTzs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0MsMEJBQTBCLDhCQUE4QjtBQUN4RDtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQywwQkFBMEIsbURBQW1EO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixvQkFBb0I7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOEJBQThCO0FBQzlEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBTSxvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYyxJQUFJLHFCQUFxQjtBQUMxRDtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0IsSUFBSSxjQUFjO0FBQ3REO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQixJQUFJLGNBQWM7QUFDdEQ7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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WTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksbUJBQU8sQ0FBQyx5RkFBTztBQUMzQixtQkFBbUIsbUJBQU8sQ0FBQyw2R0FBYztBQUN6Qyx1QkFBdUIsbUJBQU8sQ0FBQyw2SEFBeUI7QUFDeEQ7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxlcmljX1xcRGVza3RvcFxcc3luZXJneS1tYXRjaC1hcHBcXG5vZGVfbW9kdWxlc1xcLnBucG1cXG1xdWVyeUA1LjAuMFxcbm9kZV9tb2R1bGVzXFxtcXVlcnlcXGxpYlxcbXF1ZXJ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqL1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbXF1ZXJ5Jyk7XG5cbi8qKlxuICogUXVlcnkgY29uc3RydWN0b3IgdXNlZCBmb3IgYnVpbGRpbmcgcXVlcmllcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHZhciBxdWVyeSA9IG5ldyBRdWVyeSh7IG5hbWU6ICdtcXVlcnknIH0pO1xuICogICAgIHF1ZXJ5LnNldE9wdGlvbnMoeyBjb2xsZWN0aW9uOiBtb2R1bGVDb2xsZWN0aW9uIH0pXG4gKiAgICAgYXdhaXQgcXVlcnkud2hlcmUoJ2FnZScpLmd0ZSgyMSkuZXhlYygpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY3JpdGVyaWFdIGNyaXRlcmlhIGZvciB0aGUgcXVlcnkgT1IgdGhlIGNvbGxlY3Rpb24gaW5zdGFuY2UgdG8gdXNlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFF1ZXJ5KGNyaXRlcmlhLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBRdWVyeSkpXG4gICAgcmV0dXJuIG5ldyBRdWVyeShjcml0ZXJpYSwgb3B0aW9ucyk7XG5cbiAgY29uc3QgcHJvdG8gPSB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxuICB0aGlzLm9wID0gcHJvdG8ub3AgfHwgdW5kZWZpbmVkO1xuXG4gIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHByb3RvLm9wdGlvbnMpO1xuXG4gIHRoaXMuX2NvbmRpdGlvbnMgPSBwcm90by5fY29uZGl0aW9uc1xuICAgID8gdXRpbHMuY2xvbmUocHJvdG8uX2NvbmRpdGlvbnMpXG4gICAgOiB7fTtcblxuICB0aGlzLl9maWVsZHMgPSBwcm90by5fZmllbGRzXG4gICAgPyB1dGlscy5jbG9uZShwcm90by5fZmllbGRzKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIHRoaXMuX3VwZGF0ZURvYyA9IHByb3RvLl91cGRhdGVEb2NcbiAgICA/IHV0aWxzLmNsb25lKHByb3RvLl91cGRhdGVEb2MpXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgdGhpcy5fcGF0aCA9IHByb3RvLl9wYXRoIHx8IHVuZGVmaW5lZDtcbiAgdGhpcy5fZGlzdGluY3REb2MgPSBwcm90by5fZGlzdGluY3REb2MgfHwgdW5kZWZpbmVkO1xuICB0aGlzLl9jb2xsZWN0aW9uID0gcHJvdG8uX2NvbGxlY3Rpb24gfHwgdW5kZWZpbmVkO1xuICB0aGlzLl90cmFjZUZ1bmN0aW9uID0gcHJvdG8uX3RyYWNlRnVuY3Rpb24gfHwgdW5kZWZpbmVkO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKGNyaXRlcmlhKSB7XG4gICAgdGhpcy5maW5kKGNyaXRlcmlhKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYSBwYXJhbWV0ZXIgdGhhdCB0aGUgdXNlciBjYW4gc2V0IHdoaWNoIGRldGVybWluZXMgaWYgbXF1ZXJ5XG4gKiB1c2VzICR3aXRoaW4gb3IgJGdlb1dpdGhpbiBmb3IgcXVlcmllcy4gSXQgZGVmYXVsdHMgdG8gdHJ1ZSB3aGljaFxuICogbWVhbnMgJGdlb1dpdGhpbiB3aWxsIGJlIHVzZWQuIElmIHVzaW5nIE1vbmdvREIgPCAyLjQgeW91IHNob3VsZFxuICogc2V0IHRoaXMgdG8gZmFsc2UuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSB1c2UkZ2VvV2l0aGluXG4gKi9cblxubGV0ICR3aXRoaW5DbWQgPSAnJGdlb1dpdGhpbic7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUXVlcnksICd1c2UkZ2VvV2l0aGluJywge1xuICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gJHdpdGhpbkNtZCA9PSAnJGdlb1dpdGhpbic7IH0sXG4gIHNldDogZnVuY3Rpb24odikge1xuICAgIGlmICh0cnVlID09PSB2KSB7XG4gICAgICAvLyBtb25nb2RiID49IDIuNFxuICAgICAgJHdpdGhpbkNtZCA9ICckZ2VvV2l0aGluJztcbiAgICB9IGVsc2Uge1xuICAgICAgJHdpdGhpbkNtZCA9ICckd2l0aGluJztcbiAgICB9XG4gIH1cbn0pO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgcXVlcnkgdG8gYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB3aXRoIGFsbCBhcmd1bWVudHMgYW5kIG9wdGlvbnMgcmV0YWluZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBDcmVhdGUgYSBxdWVyeSB0aGF0IHdpbGwgcmVhZCBkb2N1bWVudHMgd2l0aCBhIFwidmlkZW9cIiBjYXRlZ29yeSBmcm9tXG4gKiAgICAgLy8gYGFDb2xsZWN0aW9uYCBvbiB0aGUgcHJpbWFyeSBub2RlIGluIHRoZSByZXBsaWNhLXNldCB1bmxlc3MgaXQgaXMgZG93bixcbiAqICAgICAvLyBpbiB3aGljaCBjYXNlIHdlJ2xsIHJlYWQgZnJvbSBhIHNlY29uZGFyeSBub2RlLlxuICogICAgIHZhciBxdWVyeSA9IG1xdWVyeSh7IGNhdGVnb3J5OiAndmlkZW8nIH0pXG4gKiAgICAgcXVlcnkuc2V0T3B0aW9ucyh7IGNvbGxlY3Rpb246IGFDb2xsZWN0aW9uLCByZWFkOiAncHJpbWFyeVByZWZlcnJlZCcgfSk7XG4gKlxuICogICAgIC8vIGNyZWF0ZSBhIGNvbnN0cnVjdG9yIGJhc2VkIG9mZiB0aGVzZSBzZXR0aW5nc1xuICogICAgIHZhciBWaWRlbyA9IHF1ZXJ5LnRvQ29uc3RydWN0b3IoKTtcbiAqXG4gKiAgICAgLy8gVmlkZW8gaXMgbm93IGEgc3ViY2xhc3Mgb2YgbXF1ZXJ5KCkgYW5kIHdvcmtzIHRoZSBzYW1lIHdheSBidXQgd2l0aCB0aGVcbiAqICAgICAvLyBkZWZhdWx0IHF1ZXJ5IHBhcmFtZXRlcnMgYW5kIG9wdGlvbnMgc2V0LlxuICpcbiAqICAgICAvLyBydW4gYSBxdWVyeSB3aXRoIHRoZSBwcmV2aW91cyBzZXR0aW5ncyBidXQgZmlsdGVyIGZvciBtb3ZpZXMgd2l0aCBuYW1lc1xuICogICAgIC8vIHRoYXQgc3RhcnQgd2l0aCBcIkxpZmVcIi5cbiAqICAgICBWaWRlbygpLndoZXJlKHsgbmFtZTogL15MaWZlLyB9KS5leGVjKGNiKTtcbiAqXG4gKiBAcmV0dXJuIHtRdWVyeX0gbmV3IFF1ZXJ5XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS50b0NvbnN0cnVjdG9yID0gZnVuY3Rpb24gdG9Db25zdHJ1Y3RvcigpIHtcbiAgZnVuY3Rpb24gQ3VzdG9tUXVlcnkoY3JpdGVyaWEsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ3VzdG9tUXVlcnkpKVxuICAgICAgcmV0dXJuIG5ldyBDdXN0b21RdWVyeShjcml0ZXJpYSwgb3B0aW9ucyk7XG4gICAgUXVlcnkuY2FsbCh0aGlzLCBjcml0ZXJpYSwgb3B0aW9ucyk7XG4gIH1cblxuICB1dGlscy5pbmhlcml0cyhDdXN0b21RdWVyeSwgUXVlcnkpO1xuXG4gIC8vIHNldCBpbmhlcml0ZWQgZGVmYXVsdHNcbiAgY29uc3QgcCA9IEN1c3RvbVF1ZXJ5LnByb3RvdHlwZTtcblxuICBwLm9wdGlvbnMgPSB7fTtcbiAgcC5zZXRPcHRpb25zKHRoaXMub3B0aW9ucyk7XG5cbiAgcC5vcCA9IHRoaXMub3A7XG4gIHAuX2NvbmRpdGlvbnMgPSB1dGlscy5jbG9uZSh0aGlzLl9jb25kaXRpb25zKTtcbiAgcC5fZmllbGRzID0gdXRpbHMuY2xvbmUodGhpcy5fZmllbGRzKTtcbiAgcC5fdXBkYXRlRG9jID0gdXRpbHMuY2xvbmUodGhpcy5fdXBkYXRlRG9jKTtcbiAgcC5fcGF0aCA9IHRoaXMuX3BhdGg7XG4gIHAuX2Rpc3RpbmN0RG9jID0gdGhpcy5fZGlzdGluY3REb2M7XG4gIHAuX2NvbGxlY3Rpb24gPSB0aGlzLl9jb2xsZWN0aW9uO1xuICBwLl90cmFjZUZ1bmN0aW9uID0gdGhpcy5fdHJhY2VGdW5jdGlvbjtcblxuICByZXR1cm4gQ3VzdG9tUXVlcnk7XG59O1xuXG4vKipcbiAqIFNldHMgcXVlcnkgb3B0aW9ucy5cbiAqXG4gKiAjIyMjIE9wdGlvbnM6XG4gKlxuICogLSBbdGFpbGFibGVdKGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL1RhaWxhYmxlK0N1cnNvcnMpICpcbiAqIC0gW3NvcnRdKGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FkdmFuY2VkK1F1ZXJpZXMjQWR2YW5jZWRRdWVyaWVzLSU3QiU3QnNvcnQoXFwpJTdEJTdEKSAqXG4gKiAtIFtsaW1pdF0oaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWR2YW5jZWQrUXVlcmllcyNBZHZhbmNlZFF1ZXJpZXMtJTdCJTdCbGltaXQlMjglMjklN0QlN0QpICpcbiAqIC0gW3NraXBdKGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FkdmFuY2VkK1F1ZXJpZXMjQWR2YW5jZWRRdWVyaWVzLSU3QiU3QnNraXAlMjglMjklN0QlN0QpICpcbiAqIC0gW21heFRpbWVdKGh0dHA6Ly9kb2NzLm1vbmdvZGIub3JnL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbWV0YS9tYXhUaW1lTVMvI29wLl9TX21heFRpbWVNUykgKlxuICogLSBbYmF0Y2hTaXplXShodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZHZhbmNlZCtRdWVyaWVzI0FkdmFuY2VkUXVlcmllcy0lN0IlN0JiYXRjaFNpemUlMjglMjklN0QlN0QpICpcbiAqIC0gW2NvbW1lbnRdKGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FkdmFuY2VkK1F1ZXJpZXMjQWR2YW5jZWRRdWVyaWVzLSUyNGNvbW1lbnQpICpcbiAqIC0gW2hpbnRdKGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FkdmFuY2VkK1F1ZXJpZXMjQWR2YW5jZWRRdWVyaWVzLSUyNGhpbnQpICpcbiAqIC0gW3NsYXZlT2tdKGh0dHA6Ly9kb2NzLm1vbmdvZGIub3JnL21hbnVhbC9hcHBsaWNhdGlvbnMvcmVwbGljYXRpb24vI3JlYWQtcHJlZmVyZW5jZSkgKlxuICogLSBbc2FmZV0oaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvZ2V0TGFzdEVycm9yK0NvbW1hbmQpXG4gKiAtIGNvbGxlY3Rpb24gdGhlIGNvbGxlY3Rpb24gdG8gcXVlcnkgYWdhaW5zdFxuICpcbiAqIF8qIGRlbm90ZXMgYSBxdWVyeSBoZWxwZXIgbWV0aG9kIGlzIGFsc28gYXZhaWxhYmxlX1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAoIShvcHRpb25zICYmIHV0aWxzLmlzT2JqZWN0KG9wdGlvbnMpKSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBzZXQgYXJiaXRyYXJ5IG9wdGlvbnNcbiAgY29uc3QgbWV0aG9kcyA9IHV0aWxzLmtleXMob3B0aW9ucyk7XG4gIGxldCBtZXRob2Q7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgKytpKSB7XG4gICAgbWV0aG9kID0gbWV0aG9kc1tpXTtcblxuICAgIC8vIHVzZSBtZXRob2RzIGlmIGV4aXN0IChzYWZlciBvcHRpb24gbWFuaXB1bGF0aW9uKVxuICAgIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiB0aGlzW21ldGhvZF0pIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5pc0FycmF5KG9wdGlvbnNbbWV0aG9kXSlcbiAgICAgICAgPyBvcHRpb25zW21ldGhvZF1cbiAgICAgICAgOiBbb3B0aW9uc1ttZXRob2RdXTtcbiAgICAgIHRoaXNbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcHRpb25zW21ldGhvZF0gPSBvcHRpb25zW21ldGhvZF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhpcyBRdWVyeXMgY29sbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0NvbGxlY3Rpb259IGNvbGxcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmNvbGxlY3Rpb24gPSBmdW5jdGlvbiBjb2xsZWN0aW9uKGNvbGwpIHtcbiAgdGhpcy5fY29sbGVjdGlvbiA9IG5ldyBRdWVyeS5Db2xsZWN0aW9uKGNvbGwpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgY29sbGF0aW9uIHRvIHRoaXMgb3AgKE1vbmdvREIgMy40IGFuZCB1cClcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmZpbmQoKS5jb2xsYXRpb24oeyBsb2NhbGU6IFwiZW5fVVNcIiwgc3RyZW5ndGg6IDEgfSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIE1vbmdvREIgZG9jcyBodHRwczovL2RvY3MubW9uZ29kYi5jb20vbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvY3Vyc29yLmNvbGxhdGlvbi8jY3Vyc29yLmNvbGxhdGlvblxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuY29sbGF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5vcHRpb25zLmNvbGxhdGlvbiA9IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCR3aGVyZWAgY29uZGl0aW9uXG4gKlxuICogVXNlIGAkd2hlcmVgIHdoZW4geW91IG5lZWQgdG8gc2VsZWN0IGRvY3VtZW50cyB1c2luZyBhIEphdmFTY3JpcHQgZXhwcmVzc2lvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LiR3aGVyZSgndGhpcy5jb21tZW50cy5sZW5ndGggPiAxMCB8fCB0aGlzLm5hbWUubGVuZ3RoID4gNScpXG4gKlxuICogICAgIHF1ZXJ5LiR3aGVyZShmdW5jdGlvbiAoKSB7XG4gKiAgICAgICByZXR1cm4gdGhpcy5jb21tZW50cy5sZW5ndGggPiAxMCB8fCB0aGlzLm5hbWUubGVuZ3RoID4gNTtcbiAqICAgICB9KVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBqcyBqYXZhc2NyaXB0IHN0cmluZyBvciBmdW5jdGlvblxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQG1ldGhvZCAkd2hlcmVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLiR3aGVyZSA9IGZ1bmN0aW9uKGpzKSB7XG4gIHRoaXMuX2NvbmRpdGlvbnMuJHdoZXJlID0ganM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgcGF0aGAgZm9yIHVzZSB3aXRoIGNoYWluaW5nLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gaW5zdGVhZCBvZiB3cml0aW5nOlxuICogICAgIGF3YWl0IFVzZXIuZmluZCh7YWdlOiB7JGd0ZTogMjEsICRsdGU6IDY1fX0pO1xuICpcbiAqICAgICAvLyB3ZSBjYW4gaW5zdGVhZCB3cml0ZTpcbiAqICAgICBVc2VyLndoZXJlKCdhZ2UnKS5ndGUoMjEpLmx0ZSg2NSk7XG4gKlxuICogICAgIC8vIHBhc3NpbmcgcXVlcnkgY29uZGl0aW9ucyBpcyBwZXJtaXR0ZWRcbiAqICAgICBVc2VyLmZpbmQoKS53aGVyZSh7IG5hbWU6ICd2b25kZXJmdWwnIH0pXG4gKlxuICogICAgIC8vIGNoYWluaW5nXG4gKiAgICAgYXdhaXQgVXNlclxuICogICAgICAgLndoZXJlKCdhZ2UnKS5ndGUoMjEpLmx0ZSg2NSlcbiAqICAgICAgIC53aGVyZSgnbmFtZScsIC9edm9uZGVyZnVsL2kpXG4gKiAgICAgICAud2hlcmUoJ2ZyaWVuZHMnKS5zbGljZSgxMClcbiAqICAgICAgIC5leGVjKClcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge09iamVjdH0gW3ZhbF1cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS53aGVyZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzO1xuICBpZiAoIXRoaXMub3ApIHRoaXMub3AgPSAnZmluZCc7XG5cbiAgY29uc3QgdHlwZSA9IHR5cGVvZiBhcmd1bWVudHNbMF07XG5cbiAgaWYgKCdzdHJpbmcnID09IHR5cGUpIHtcbiAgICB0aGlzLl9wYXRoID0gYXJndW1lbnRzWzBdO1xuXG4gICAgaWYgKDIgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2NvbmRpdGlvbnNbdGhpcy5fcGF0aF0gPSBhcmd1bWVudHNbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAoJ29iamVjdCcgPT0gdHlwZSAmJiAhQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgcmV0dXJuIHRoaXMubWVyZ2UoYXJndW1lbnRzWzBdKTtcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhdGggbXVzdCBiZSBhIHN0cmluZyBvciBvYmplY3QnKTtcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBjb21wbGVtZW50YXJ5IGNvbXBhcmlzb24gdmFsdWUgZm9yIHBhdGhzIHNwZWNpZmllZCB3aXRoIGB3aGVyZSgpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgVXNlci53aGVyZSgnYWdlJykuZXF1YWxzKDQ5KTtcbiAqXG4gKiAgICAgLy8gaXMgdGhlIHNhbWUgYXNcbiAqXG4gKiAgICAgVXNlci53aGVyZSgnYWdlJywgNDkpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWxcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHModmFsKSB7XG4gIHRoaXMuX2Vuc3VyZVBhdGgoJ2VxdWFscycpO1xuICBjb25zdCBwYXRoID0gdGhpcy5fcGF0aDtcbiAgdGhpcy5fY29uZGl0aW9uc1twYXRoXSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgY29tcGxlbWVudGFyeSBjb21wYXJpc29uIHZhbHVlIGZvciBwYXRocyBzcGVjaWZpZWQgd2l0aCBgd2hlcmUoKWBcbiAqIFRoaXMgaXMgYWxpYXMgb2YgYGVxdWFsc2BcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIFVzZXIud2hlcmUoJ2FnZScpLmVxKDQ5KTtcbiAqXG4gKiAgICAgLy8gaXMgdGhlIHNhbWUgYXNcbiAqXG4gKiAgICAgVXNlci5zaGVyZSgnYWdlJykuZXF1YWxzKDQ5KTtcbiAqXG4gKiAgICAgLy8gaXMgdGhlIHNhbWUgYXNcbiAqXG4gKiAgICAgVXNlci53aGVyZSgnYWdlJywgNDkpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWxcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKHZhbCkge1xuICB0aGlzLl9lbnN1cmVQYXRoKCdlcScpO1xuICBjb25zdCBwYXRoID0gdGhpcy5fcGF0aDtcbiAgdGhpcy5fY29uZGl0aW9uc1twYXRoXSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhcmd1bWVudHMgZm9yIGFuIGAkb3JgIGNvbmRpdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5Lm9yKFt7IGNvbG9yOiAncmVkJyB9LCB7IHN0YXR1czogJ2VtZXJnZW5jeScgfV0pXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgYXJyYXkgb2YgY29uZGl0aW9uc1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3IoYXJyYXkpIHtcbiAgY29uc3Qgb3IgPSB0aGlzLl9jb25kaXRpb25zLiRvciB8fCAodGhpcy5fY29uZGl0aW9ucy4kb3IgPSBbXSk7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIGFycmF5ID0gW2FycmF5XTtcbiAgb3IucHVzaC5hcHBseShvciwgYXJyYXkpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGFyZ3VtZW50cyBmb3IgYSBgJG5vcmAgY29uZGl0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkubm9yKFt7IGNvbG9yOiAnZ3JlZW4nIH0sIHsgc3RhdHVzOiAnb2snIH1dKVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IGFycmF5IG9mIGNvbmRpdGlvbnNcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5ub3IgPSBmdW5jdGlvbiBub3IoYXJyYXkpIHtcbiAgY29uc3Qgbm9yID0gdGhpcy5fY29uZGl0aW9ucy4kbm9yIHx8ICh0aGlzLl9jb25kaXRpb25zLiRub3IgPSBbXSk7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIGFycmF5ID0gW2FycmF5XTtcbiAgbm9yLnB1c2guYXBwbHkobm9yLCBhcnJheSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYXJndW1lbnRzIGZvciBhIGAkYW5kYCBjb25kaXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5hbmQoW3sgY29sb3I6ICdncmVlbicgfSwgeyBzdGF0dXM6ICdvaycgfV0pXG4gKlxuICogQHNlZSAkYW5kIGh0dHA6Ly9kb2NzLm1vbmdvZGIub3JnL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvYW5kL1xuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgYXJyYXkgb2YgY29uZGl0aW9uc1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZChhcnJheSkge1xuICBjb25zdCBhbmQgPSB0aGlzLl9jb25kaXRpb25zLiRhbmQgfHwgKHRoaXMuX2NvbmRpdGlvbnMuJGFuZCA9IFtdKTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkgYXJyYXkgPSBbYXJyYXldO1xuICBhbmQucHVzaC5hcHBseShhbmQsIGFycmF5KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhICRndCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIFRoaW5nLmZpbmQoKS53aGVyZSgnYWdlJykuZ3QoMjEpXG4gKlxuICogICAgIC8vIG9yXG4gKiAgICAgVGhpbmcuZmluZCgpLmd0KCdhZ2UnLCAyMSlcbiAqXG4gKiBAbWV0aG9kIGd0XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSAkZ3RlIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBtZXRob2QgZ3RlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSAkbHQgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCBsdFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgJGx0ZSBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAbWV0aG9kIGx0ZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgJG5lIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBtZXRob2QgbmVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhbiAkaW4gcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCBpblxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGFuICRuaW4gcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCBuaW5cbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhbiAkYWxsIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBtZXRob2QgYWxsXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSAkc2l6ZSBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAbWV0aG9kIHNpemVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhICRyZWdleCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAbWV0aG9kIHJlZ2V4XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgJG1heERpc3RhbmNlIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBtZXRob2QgbWF4RGlzdGFuY2VcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKiFcbiAqIGd0LCBndGUsIGx0LCBsdGUsIG5lLCBpbiwgbmluLCBhbGwsIHJlZ2V4LCBzaXplLCBtYXhEaXN0YW5jZVxuICpcbiAqICAgICBUaGluZy53aGVyZSgndHlwZScpLm5pbihhcnJheSlcbiAqL1xuXG4nZ3QgZ3RlIGx0IGx0ZSBuZSBpbiBuaW4gYWxsIHJlZ2V4IHNpemUgbWF4RGlzdGFuY2UgbWluRGlzdGFuY2UnLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbigkY29uZGl0aW9uYWwpIHtcbiAgUXVlcnkucHJvdG90eXBlWyRjb25kaXRpb25hbF0gPSBmdW5jdGlvbigpIHtcbiAgICBsZXQgcGF0aCwgdmFsO1xuXG4gICAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2Vuc3VyZVBhdGgoJGNvbmRpdGlvbmFsKTtcbiAgICAgIHZhbCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWwgPSBhcmd1bWVudHNbMV07XG4gICAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9uc1twYXRoXSA9PT0gbnVsbCB8fCB0eXBlb2YgdGhpcy5fY29uZGl0aW9uc1twYXRoXSA9PT0gJ29iamVjdCcgP1xuICAgICAgdGhpcy5fY29uZGl0aW9uc1twYXRoXSA6XG4gICAgICAodGhpcy5fY29uZGl0aW9uc1twYXRoXSA9IHt9KTtcbiAgICBjb25kc1snJCcgKyAkY29uZGl0aW9uYWxdID0gdmFsO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xufSk7XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCRtb2RgIGNvbmRpdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbigpIHtcbiAgbGV0IHZhbCwgcGF0aDtcblxuICBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ21vZCcpO1xuICAgIHZhbCA9IGFyZ3VtZW50c1swXTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgfSBlbHNlIGlmICgyID09PSBhcmd1bWVudHMubGVuZ3RoICYmICFBcnJheS5pc0FycmF5KGFyZ3VtZW50c1sxXSkpIHtcbiAgICB0aGlzLl9lbnN1cmVQYXRoKCdtb2QnKTtcbiAgICB2YWwgPSBbYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV1dO1xuICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICB9IGVsc2UgaWYgKDMgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB2YWwgPSBbYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl1dO1xuICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gYXJndW1lbnRzWzFdO1xuICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gIH1cblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gfHwgKHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPSB7fSk7XG4gIGNvbmRzLiRtb2QgPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYW4gYCRleGlzdHNgIGNvbmRpdGlvblxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8geyBuYW1lOiB7ICRleGlzdHM6IHRydWUgfX1cbiAqICAgICBUaGluZy53aGVyZSgnbmFtZScpLmV4aXN0cygpXG4gKiAgICAgVGhpbmcud2hlcmUoJ25hbWUnKS5leGlzdHModHJ1ZSlcbiAqICAgICBUaGluZy5maW5kKCkuZXhpc3RzKCduYW1lJylcbiAqXG4gKiAgICAgLy8geyBuYW1lOiB7ICRleGlzdHM6IGZhbHNlIH19XG4gKiAgICAgVGhpbmcud2hlcmUoJ25hbWUnKS5leGlzdHMoZmFsc2UpO1xuICogICAgIFRoaW5nLmZpbmQoKS5leGlzdHMoJ25hbWUnLCBmYWxzZSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uKCkge1xuICBsZXQgcGF0aCwgdmFsO1xuXG4gIGlmICgwID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnZXhpc3RzJyk7XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgdmFsID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgaWYgKCdib29sZWFuJyA9PT0gdHlwZW9mIGFyZ3VtZW50c1swXSkge1xuICAgICAgdGhpcy5fZW5zdXJlUGF0aCgnZXhpc3RzJyk7XG4gICAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICAgIHZhbCA9IGFyZ3VtZW50c1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhbCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKDIgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbCA9IGFyZ3VtZW50c1sxXTtcbiAgfVxuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9uc1twYXRoXSB8fCAodGhpcy5fY29uZGl0aW9uc1twYXRoXSA9IHt9KTtcbiAgY29uZHMuJGV4aXN0cyA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhbiBgJGVsZW1NYXRjaGAgY29uZGl0aW9uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5lbGVtTWF0Y2goJ2NvbW1lbnQnLCB7IGF1dGhvcjogJ2F1dG9ib3QnLCB2b3RlczogeyRndGU6IDV9fSlcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2NvbW1lbnQnKS5lbGVtTWF0Y2goeyBhdXRob3I6ICdhdXRvYm90Jywgdm90ZXM6IHskZ3RlOiA1fX0pXG4gKlxuICogICAgIHF1ZXJ5LmVsZW1NYXRjaCgnY29tbWVudCcsIGZ1bmN0aW9uIChlbGVtKSB7XG4gKiAgICAgICBlbGVtLndoZXJlKCdhdXRob3InKS5lcXVhbHMoJ2F1dG9ib3QnKTtcbiAqICAgICAgIGVsZW0ud2hlcmUoJ3ZvdGVzJykuZ3RlKDUpO1xuICogICAgIH0pXG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdjb21tZW50JykuZWxlbU1hdGNoKGZ1bmN0aW9uIChlbGVtKSB7XG4gKiAgICAgICBlbGVtLndoZXJlKHsgYXV0aG9yOiAnYXV0b2JvdCcgfSk7XG4gKiAgICAgICBlbGVtLndoZXJlKCd2b3RlcycpLmd0ZSg1KTtcbiAqICAgICB9KVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxGdW5jdGlvbn0gcGF0aFxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IGNyaXRlcmlhXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZWxlbU1hdGNoID0gZnVuY3Rpb24oKSB7XG4gIGlmIChudWxsID09IGFyZ3VtZW50c1swXSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50Jyk7XG5cbiAgbGV0IGZuLCBwYXRoLCBjcml0ZXJpYTtcblxuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGFyZ3VtZW50c1swXSkge1xuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ2VsZW1NYXRjaCcpO1xuICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgIGZuID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KGFyZ3VtZW50c1swXSkpIHtcbiAgICB0aGlzLl9lbnN1cmVQYXRoKCdlbGVtTWF0Y2gnKTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICBjcml0ZXJpYSA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYXJndW1lbnRzWzFdKSB7XG4gICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICBmbiA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMV0gJiYgdXRpbHMuaXNPYmplY3QoYXJndW1lbnRzWzFdKSkge1xuICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgY3JpdGVyaWEgPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCcpO1xuICB9XG5cbiAgaWYgKGZuKSB7XG4gICAgY3JpdGVyaWEgPSBuZXcgUXVlcnk7XG4gICAgZm4oY3JpdGVyaWEpO1xuICAgIGNyaXRlcmlhID0gY3JpdGVyaWEuX2NvbmRpdGlvbnM7XG4gIH1cblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gfHwgKHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPSB7fSk7XG4gIGNvbmRzLiRlbGVtTWF0Y2ggPSBjcml0ZXJpYTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBTcGF0aWFsIHF1ZXJpZXNcblxuLyoqXG4gKiBTdWdhciBmb3IgZ2VvLXNwYXRpYWwgcXVlcmllcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LndpdGhpbigpLmJveCgpXG4gKiAgICAgcXVlcnkud2l0aGluKCkuY2lyY2xlKClcbiAqICAgICBxdWVyeS53aXRoaW4oKS5nZW9tZXRyeSgpXG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oeyBjZW50ZXI6IFs1MCw1MF0sIHJhZGl1czogMTAsIHVuaXF1ZTogdHJ1ZSwgc3BoZXJpY2FsOiB0cnVlIH0pO1xuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oeyBib3g6IFtbNDAuNzMsIC03My45XSwgWzQwLjcsIC03My45ODhdXSB9KTtcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKHsgcG9seWdvbjogW1tdLFtdLFtdLFtdXSB9KTtcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbihbXSwgW10sIFtdKSAvLyBwb2x5Z29uXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbihbXSwgW10pIC8vIGJveFxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oeyB0eXBlOiAnTGluZVN0cmluZycsIGNvb3JkaW5hdGVzOiBbLi4uXSB9KTsgLy8gZ2VvbWV0cnlcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogTXVzdCBiZSB1c2VkIGFmdGVyIGB3aGVyZSgpYC5cbiAqXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS53aXRoaW4gPSBmdW5jdGlvbiB3aXRoaW4oKSB7XG4gIC8vIG9waW5pb25hdGVkLCBtdXN0IGJlIHVzZWQgYWZ0ZXIgd2hlcmVcbiAgdGhpcy5fZW5zdXJlUGF0aCgnd2l0aGluJyk7XG4gIHRoaXMuX2dlb0NvbXBhcmlzb24gPSAkd2l0aGluQ21kO1xuXG4gIGlmICgwID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAoMiA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLmJveC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9IGVsc2UgaWYgKDIgPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9seWdvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgY29uc3QgYXJlYSA9IGFyZ3VtZW50c1swXTtcblxuICBpZiAoIWFyZWEpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCcpO1xuXG4gIGlmIChhcmVhLmNlbnRlcilcbiAgICByZXR1cm4gdGhpcy5jaXJjbGUoYXJlYSk7XG5cbiAgaWYgKGFyZWEuYm94KVxuICAgIHJldHVybiB0aGlzLmJveC5hcHBseSh0aGlzLCBhcmVhLmJveCk7XG5cbiAgaWYgKGFyZWEucG9seWdvbilcbiAgICByZXR1cm4gdGhpcy5wb2x5Z29uLmFwcGx5KHRoaXMsIGFyZWEucG9seWdvbik7XG5cbiAgaWYgKGFyZWEudHlwZSAmJiBhcmVhLmNvb3JkaW5hdGVzKVxuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5KGFyZWEpO1xuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgJGJveCBjb25kaXRpb25cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHZhciBsb3dlckxlZnQgPSBbNDAuNzMwODMsIC03My45OTc1Nl1cbiAqICAgICB2YXIgdXBwZXJSaWdodD0gWzQwLjc0MTQwNCwgIC03My45ODgxMzVdXG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oKS5ib3gobG93ZXJMZWZ0LCB1cHBlclJpZ2h0KVxuICogICAgIHF1ZXJ5LmJveCgnbG9jJywgbG93ZXJMZWZ0LCB1cHBlclJpZ2h0IClcbiAqXG4gKiBAc2VlIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0dlb3NwYXRpYWwrSW5kZXhpbmdcbiAqIEBzZWUgUXVlcnkjd2l0aGluICNxdWVyeV9RdWVyeS13aXRoaW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuYm94ID0gZnVuY3Rpb24oKSB7XG4gIGxldCBwYXRoLCBib3g7XG5cbiAgaWYgKDMgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAvLyBib3goJ2xvYycsIFtdLCBbXSlcbiAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIGJveCA9IFthcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXV07XG4gIH0gZWxzZSBpZiAoMiA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIC8vIGJveChbXSwgW10pXG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnYm94Jyk7XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgYm94ID0gW2FyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdXTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50Jyk7XG4gIH1cblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gfHwgKHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPSB7fSk7XG4gIGNvbmRzW3RoaXMuX2dlb0NvbXBhcmlzb24gfHwgJHdpdGhpbkNtZF0gPSB7ICRib3g6IGJveCB9O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgJHBvbHlnb24gY29uZGl0aW9uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKCkucG9seWdvbihbMTAsMjBdLCBbMTMsIDI1XSwgWzcsMTVdKVxuICogICAgIHF1ZXJ5LnBvbHlnb24oJ2xvYycsIFsxMCwyMF0sIFsxMywgMjVdLCBbNywxNV0pXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IFtwYXRoXVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IFt2YWxdXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9HZW9zcGF0aWFsK0luZGV4aW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5wb2x5Z29uID0gZnVuY3Rpb24oKSB7XG4gIGxldCB2YWwsIHBhdGg7XG5cbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBhcmd1bWVudHNbMF0pIHtcbiAgICAvLyBwb2x5Z29uKCdsb2MnLCBbXSxbXSxbXSlcbiAgICB2YWwgPSBBcnJheS5mcm9tKGFyZ3VtZW50cyk7XG4gICAgcGF0aCA9IHZhbC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHBvbHlnb24oW10sW10sW10pXG4gICAgdGhpcy5fZW5zdXJlUGF0aCgncG9seWdvbicpO1xuICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgIHZhbCA9IEFycmF5LmZyb20oYXJndW1lbnRzKTtcbiAgfVxuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9uc1twYXRoXSB8fCAodGhpcy5fY29uZGl0aW9uc1twYXRoXSA9IHt9KTtcbiAgY29uZHNbdGhpcy5fZ2VvQ29tcGFyaXNvbiB8fCAkd2l0aGluQ21kXSA9IHsgJHBvbHlnb246IHZhbCB9O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgJGNlbnRlciBvciAkY2VudGVyU3BoZXJlIGNvbmRpdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHZhciBhcmVhID0geyBjZW50ZXI6IFs1MCwgNTBdLCByYWRpdXM6IDEwLCB1bmlxdWU6IHRydWUgfVxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oKS5jaXJjbGUoYXJlYSlcbiAqICAgICBxdWVyeS5jZW50ZXIoJ2xvYycsIGFyZWEpO1xuICpcbiAqICAgICAvLyBmb3Igc3BoZXJpY2FsIGNhbGN1bGF0aW9uc1xuICogICAgIHZhciBhcmVhID0geyBjZW50ZXI6IFs1MCwgNTBdLCByYWRpdXM6IDEwLCB1bmlxdWU6IHRydWUsIHNwaGVyaWNhbDogdHJ1ZSB9XG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmNpcmNsZShhcmVhKVxuICogICAgIHF1ZXJ5LmNlbnRlcignbG9jJywgYXJlYSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtPYmplY3R9IGFyZWFcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0dlb3NwYXRpYWwrSW5kZXhpbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmNpcmNsZSA9IGZ1bmN0aW9uKCkge1xuICBsZXQgcGF0aCwgdmFsO1xuXG4gIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnY2lyY2xlJyk7XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgdmFsID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKDIgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbCA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50Jyk7XG4gIH1cblxuICBpZiAoISgncmFkaXVzJyBpbiB2YWwgJiYgdmFsLmNlbnRlcikpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjZW50ZXIgYW5kIHJhZGl1cyBhcmUgcmVxdWlyZWQnKTtcblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gfHwgKHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPSB7fSk7XG5cbiAgY29uc3QgdHlwZSA9IHZhbC5zcGhlcmljYWxcbiAgICA/ICckY2VudGVyU3BoZXJlJ1xuICAgIDogJyRjZW50ZXInO1xuXG4gIGNvbnN0IHdLZXkgPSB0aGlzLl9nZW9Db21wYXJpc29uIHx8ICR3aXRoaW5DbWQ7XG4gIGNvbmRzW3dLZXldID0ge307XG4gIGNvbmRzW3dLZXldW3R5cGVdID0gW3ZhbC5jZW50ZXIsIHZhbC5yYWRpdXNdO1xuXG4gIGlmICgndW5pcXVlJyBpbiB2YWwpXG4gICAgY29uZHNbd0tleV0uJHVuaXF1ZURvY3MgPSAhIXZhbC51bmlxdWU7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGAkbmVhcmAgb3IgYCRuZWFyU3BoZXJlYCBjb25kaXRpb25cbiAqXG4gKiBUaGVzZSBvcGVyYXRvcnMgcmV0dXJuIGRvY3VtZW50cyBzb3J0ZWQgYnkgZGlzdGFuY2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykubmVhcih7IGNlbnRlcjogWzEwLCAxMF0gfSk7XG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLm5lYXIoeyBjZW50ZXI6IFsxMCwgMTBdLCBtYXhEaXN0YW5jZTogNSB9KTtcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykubmVhcih7IGNlbnRlcjogWzEwLCAxMF0sIG1heERpc3RhbmNlOiA1LCBzcGhlcmljYWw6IHRydWUgfSk7XG4gKiAgICAgcXVlcnkubmVhcignbG9jJywgeyBjZW50ZXI6IFsxMCwgMTBdLCBtYXhEaXN0YW5jZTogNSB9KTtcbiAqICAgICBxdWVyeS5uZWFyKHsgY2VudGVyOiB7IHR5cGU6ICdQb2ludCcsIGNvb3JkaW5hdGVzOiBbLi5dIH19KVxuICogICAgIHF1ZXJ5Lm5lYXIoKS5nZW9tZXRyeSh7IHR5cGU6ICdQb2ludCcsIGNvb3JkaW5hdGVzOiBbLi5dIH0pXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtPYmplY3R9IHZhbFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvR2Vvc3BhdGlhbCtJbmRleGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubmVhciA9IGZ1bmN0aW9uIG5lYXIoKSB7XG4gIGxldCBwYXRoLCB2YWw7XG5cbiAgdGhpcy5fZ2VvQ29tcGFyaXNvbiA9ICckbmVhcic7XG5cbiAgaWYgKDAgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnbmVhcicpO1xuICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgIHZhbCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIGlmICgyID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YWwgPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCcpO1xuICB9XG5cbiAgaWYgKCF2YWwuY2VudGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjZW50ZXIgaXMgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9uc1twYXRoXSB8fCAodGhpcy5fY29uZGl0aW9uc1twYXRoXSA9IHt9KTtcblxuICBjb25zdCB0eXBlID0gdmFsLnNwaGVyaWNhbFxuICAgID8gJyRuZWFyU3BoZXJlJ1xuICAgIDogJyRuZWFyJztcblxuICAvLyBjZW50ZXIgY291bGQgYmUgYSBHZW9KU09OIG9iamVjdCBvciBhbiBBcnJheVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwuY2VudGVyKSkge1xuICAgIGNvbmRzW3R5cGVdID0gdmFsLmNlbnRlcjtcblxuICAgIGNvbnN0IHJhZGl1cyA9ICdtYXhEaXN0YW5jZScgaW4gdmFsXG4gICAgICA/IHZhbC5tYXhEaXN0YW5jZVxuICAgICAgOiBudWxsO1xuXG4gICAgaWYgKG51bGwgIT0gcmFkaXVzKSB7XG4gICAgICBjb25kcy4kbWF4RGlzdGFuY2UgPSByYWRpdXM7XG4gICAgfVxuICAgIGlmIChudWxsICE9IHZhbC5taW5EaXN0YW5jZSkge1xuICAgICAgY29uZHMuJG1pbkRpc3RhbmNlID0gdmFsLm1pbkRpc3RhbmNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBHZW9KU09OP1xuICAgIGlmICh2YWwuY2VudGVyLnR5cGUgIT0gJ1BvaW50JyB8fCAhQXJyYXkuaXNBcnJheSh2YWwuY2VudGVyLmNvb3JkaW5hdGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWwuZm9ybWF0KCdJbnZhbGlkIEdlb0pTT04gc3BlY2lmaWVkIGZvciAlcycsIHR5cGUpKTtcbiAgICB9XG4gICAgY29uZHNbdHlwZV0gPSB7ICRnZW9tZXRyeTogdmFsLmNlbnRlciB9O1xuXG4gICAgLy8gTW9uZ29EQiAyLjYgaW5zaXN0cyBvbiBtYXhEaXN0YW5jZSBiZWluZyBpbiAkbmVhciAvICRuZWFyU3BoZXJlXG4gICAgaWYgKCdtYXhEaXN0YW5jZScgaW4gdmFsKSB7XG4gICAgICBjb25kc1t0eXBlXVsnJG1heERpc3RhbmNlJ10gPSB2YWwubWF4RGlzdGFuY2U7XG4gICAgfVxuICAgIGlmICgnbWluRGlzdGFuY2UnIGluIHZhbCkge1xuICAgICAgY29uZHNbdHlwZV1bJyRtaW5EaXN0YW5jZSddID0gdmFsLm1pbkRpc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlcyBhbiBpbnRlcnNlY3RzIHF1ZXJ5IGZvciBgZ2VvbWV0cnkoKWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS53aGVyZSgncGF0aCcpLmludGVyc2VjdHMoKS5nZW9tZXRyeSh7XG4gKiAgICAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJ1xuICogICAgICAgLCBjb29yZGluYXRlczogW1sxODAuMCwgMTEuMF0sIFsxODAsIDkuMF1dXG4gKiAgICAgfSlcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ3BhdGgnKS5pbnRlcnNlY3RzKHtcbiAqICAgICAgICAgdHlwZTogJ0xpbmVTdHJpbmcnXG4gKiAgICAgICAsIGNvb3JkaW5hdGVzOiBbWzE4MC4wLCAxMS4wXSwgWzE4MCwgOS4wXV1cbiAqICAgICB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbiBpbnRlcnNlY3RzKCkge1xuICAvLyBvcGluaW9uYXRlZCwgbXVzdCBiZSB1c2VkIGFmdGVyIHdoZXJlXG4gIHRoaXMuX2Vuc3VyZVBhdGgoJ2ludGVyc2VjdHMnKTtcblxuICB0aGlzLl9nZW9Db21wYXJpc29uID0gJyRnZW9JbnRlcnNlY3RzJztcblxuICBpZiAoMCA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY29uc3QgYXJlYSA9IGFyZ3VtZW50c1swXTtcblxuICBpZiAobnVsbCAhPSBhcmVhICYmIGFyZWEudHlwZSAmJiBhcmVhLmNvb3JkaW5hdGVzKVxuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5KGFyZWEpO1xuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCRnZW9tZXRyeWAgY29uZGl0aW9uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICB2YXIgcG9seUEgPSBbW1sgMTAsIDIwIF0sIFsgMTAsIDQwIF0sIFsgMzAsIDQwIF0sIFsgMzAsIDIwIF1dXVxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oKS5nZW9tZXRyeSh7IHR5cGU6ICdQb2x5Z29uJywgY29vcmRpbmF0ZXM6IHBvbHlBIH0pXG4gKlxuICogICAgIC8vIG9yXG4gKiAgICAgdmFyIHBvbHlCID0gW1sgMCwgMCBdLCBbIDEsIDEgXV1cbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKCkuZ2VvbWV0cnkoeyB0eXBlOiAnTGluZVN0cmluZycsIGNvb3JkaW5hdGVzOiBwb2x5QiB9KVxuICpcbiAqICAgICAvLyBvclxuICogICAgIHZhciBwb2x5QyA9IFsgMCwgMCBdXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmdlb21ldHJ5KHsgdHlwZTogJ1BvaW50JywgY29vcmRpbmF0ZXM6IHBvbHlDIH0pXG4gKlxuICogICAgIC8vIG9yXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLmludGVyc2VjdHMoKS5nZW9tZXRyeSh7IHR5cGU6ICdQb2ludCcsIGNvb3JkaW5hdGVzOiBwb2x5QyB9KVxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBgZ2VvbWV0cnkoKWAgKiptdXN0KiogY29tZSBhZnRlciBlaXRoZXIgYGludGVyc2VjdHMoKWAgb3IgYHdpdGhpbigpYC5cbiAqXG4gKiBUaGUgYG9iamVjdGAgYXJndW1lbnQgbXVzdCBjb250YWluIGB0eXBlYCBhbmQgYGNvb3JkaW5hdGVzYCBwcm9wZXJ0aWVzLlxuICogLSB0eXBlIHtTdHJpbmd9XG4gKiAtIGNvb3JkaW5hdGVzIHtBcnJheX1cbiAqXG4gKiBUaGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBNdXN0IGNvbnRhaW4gYSBgdHlwZWAgcHJvcGVydHkgd2hpY2ggaXMgYSBTdHJpbmcgYW5kIGEgYGNvb3JkaW5hdGVzYCBwcm9wZXJ0eSB3aGljaCBpcyBhbiBBcnJheS4gU2VlIHRoZSBleGFtcGxlcy5cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIGh0dHA6Ly9kb2NzLm1vbmdvZGIub3JnL21hbnVhbC9yZWxlYXNlLW5vdGVzLzIuNC8jbmV3LWdlb3NwYXRpYWwtaW5kZXhlcy13aXRoLWdlb2pzb24tYW5kLWltcHJvdmVkLXNwaGVyaWNhbC1nZW9tZXRyeVxuICogQHNlZSBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9HZW9zcGF0aWFsK0luZGV4aW5nXG4gKiBAc2VlICRnZW9tZXRyeSBodHRwOi8vZG9jcy5tb25nb2RiLm9yZy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2dlb21ldHJ5L1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZ2VvbWV0cnkgPSBmdW5jdGlvbiBnZW9tZXRyeSgpIHtcbiAgaWYgKCEoJyR3aXRoaW4nID09IHRoaXMuX2dlb0NvbXBhcmlzb24gfHxcbiAgICAgICAgJyRnZW9XaXRoaW4nID09IHRoaXMuX2dlb0NvbXBhcmlzb24gfHxcbiAgICAgICAgJyRuZWFyJyA9PSB0aGlzLl9nZW9Db21wYXJpc29uIHx8XG4gICAgICAgICckZ2VvSW50ZXJzZWN0cycgPT0gdGhpcy5fZ2VvQ29tcGFyaXNvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlb21ldHJ5KCkgbXVzdCBjb21lIGFmdGVyIGB3aXRoaW4oKWAsIGBpbnRlcnNlY3RzKClgLCBvciBgbmVhcigpJyk7XG4gIH1cblxuICBsZXQgdmFsLCBwYXRoO1xuXG4gIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnZ2VvbWV0cnknKTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICB2YWwgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCcpO1xuICB9XG5cbiAgaWYgKCEodmFsLnR5cGUgJiYgQXJyYXkuaXNBcnJheSh2YWwuY29vcmRpbmF0ZXMpKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcbiAgfVxuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9uc1twYXRoXSB8fCAodGhpcy5fY29uZGl0aW9uc1twYXRoXSA9IHt9KTtcbiAgY29uZHNbdGhpcy5fZ2VvQ29tcGFyaXNvbl0gPSB7ICRnZW9tZXRyeTogdmFsIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbmQgc3BhdGlhbFxuXG4vKipcbiAqIFNwZWNpZmllcyB3aGljaCBkb2N1bWVudCBmaWVsZHMgdG8gaW5jbHVkZSBvciBleGNsdWRlXG4gKlxuICogIyMjIyBTdHJpbmcgc3ludGF4XG4gKlxuICogV2hlbiBwYXNzaW5nIGEgc3RyaW5nLCBwcmVmaXhpbmcgYSBwYXRoIHdpdGggYC1gIHdpbGwgZmxhZyB0aGF0IHBhdGggYXMgZXhjbHVkZWQuIFdoZW4gYSBwYXRoIGRvZXMgbm90IGhhdmUgdGhlIGAtYCBwcmVmaXgsIGl0IGlzIGluY2x1ZGVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gaW5jbHVkZSBhIGFuZCBiLCBleGNsdWRlIGNcbiAqICAgICBxdWVyeS5zZWxlY3QoJ2EgYiAtYycpO1xuICpcbiAqICAgICAvLyBvciB5b3UgbWF5IHVzZSBvYmplY3Qgbm90YXRpb24sIHVzZWZ1bCB3aGVuXG4gKiAgICAgLy8geW91IGhhdmUga2V5cyBhbHJlYWR5IHByZWZpeGVkIHdpdGggYSBcIi1cIlxuICogICAgIHF1ZXJ5LnNlbGVjdCh7YTogMSwgYjogMSwgYzogMH0pO1xuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBDYW5ub3QgYmUgdXNlZCB3aXRoIGBkaXN0aW5jdCgpYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gYXJnXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBTY2hlbWFUeXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiBzZWxlY3QoKSB7XG4gIGxldCBhcmcgPSBhcmd1bWVudHNbMF07XG4gIGlmICghYXJnKSByZXR1cm4gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3Q6IHNlbGVjdCBvbmx5IHRha2VzIDEgYXJndW1lbnQnKTtcbiAgfVxuXG4gIHRoaXMuX3ZhbGlkYXRlKCdzZWxlY3QnKTtcblxuICBjb25zdCBmaWVsZHMgPSB0aGlzLl9maWVsZHMgfHwgKHRoaXMuX2ZpZWxkcyA9IHt9KTtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiBhcmc7XG4gIGxldCBpLCBsZW47XG5cbiAgaWYgKCgnc3RyaW5nJyA9PSB0eXBlIHx8IHV0aWxzLmlzQXJndW1lbnRzT2JqZWN0KGFyZykpICYmXG4gICAgJ251bWJlcicgPT0gdHlwZW9mIGFyZy5sZW5ndGggfHwgQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgaWYgKCdzdHJpbmcnID09IHR5cGUpXG4gICAgICBhcmcgPSBhcmcuc3BsaXQoL1xccysvKTtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGFyZy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgbGV0IGZpZWxkID0gYXJnW2ldO1xuICAgICAgaWYgKCFmaWVsZCkgY29udGludWU7XG4gICAgICBjb25zdCBpbmNsdWRlID0gJy0nID09IGZpZWxkWzBdID8gMCA6IDE7XG4gICAgICBpZiAoaW5jbHVkZSA9PT0gMCkgZmllbGQgPSBmaWVsZC5zdWJzdHJpbmcoMSk7XG4gICAgICBmaWVsZHNbZmllbGRdID0gaW5jbHVkZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICh1dGlscy5pc09iamVjdChhcmcpKSB7XG4gICAgY29uc3Qga2V5cyA9IHV0aWxzLmtleXMoYXJnKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgZmllbGRzW2tleXNbaV1dID0gYXJnW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc2VsZWN0KCkgYXJndW1lbnQuIE11c3QgYmUgc3RyaW5nIG9yIG9iamVjdC4nKTtcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgJHNsaWNlIGNvbmRpdGlvbiBmb3IgYSBgcGF0aGBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LnNsaWNlKCdjb21tZW50cycsIDUpXG4gKiAgICAgcXVlcnkuc2xpY2UoJ2NvbW1lbnRzJywgLTUpXG4gKiAgICAgcXVlcnkuc2xpY2UoJ2NvbW1lbnRzJywgWzEwLCA1XSlcbiAqICAgICBxdWVyeS53aGVyZSgnY29tbWVudHMnKS5zbGljZSg1KVxuICogICAgIHF1ZXJ5LndoZXJlKCdjb21tZW50cycpLnNsaWNlKFstMTAsIDVdKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWwgbnVtYmVyL3JhbmdlIG9mIGVsZW1lbnRzIHRvIHNsaWNlXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBtb25nb2RiIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL1JldHJpZXZpbmcrYStTdWJzZXQrb2YrRmllbGRzI1JldHJpZXZpbmdhU3Vic2V0b2ZGaWVsZHMtUmV0cmlldmluZ2FTdWJyYW5nZW9mQXJyYXlFbGVtZW50c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKDAgPT09IGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgdGhpcy5fdmFsaWRhdGUoJ3NsaWNlJyk7XG5cbiAgbGV0IHBhdGgsIHZhbDtcblxuICBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNvbnN0IGFyZyA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGFyZyk7XG4gICAgICBjb25zdCBudW1LZXlzID0ga2V5cy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUtleXM7ICsraSkge1xuICAgICAgICB0aGlzLnNsaWNlKGtleXNbaV0sIGFyZ1trZXlzW2ldXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnc2xpY2UnKTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICB2YWwgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSBpZiAoMiA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIGFyZ3VtZW50c1swXSkge1xuICAgICAgdGhpcy5fZW5zdXJlUGF0aCgnc2xpY2UnKTtcbiAgICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgICAgdmFsID0gW2FyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhbCA9IGFyZ3VtZW50c1sxXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoMyA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsID0gW2FyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdXTtcbiAgfVxuXG4gIGNvbnN0IG15RmllbGRzID0gdGhpcy5fZmllbGRzIHx8ICh0aGlzLl9maWVsZHMgPSB7fSk7XG4gIG15RmllbGRzW3BhdGhdID0geyAkc2xpY2U6IHZhbCB9O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgc29ydCBvcmRlclxuICpcbiAqIElmIGFuIG9iamVjdCBpcyBwYXNzZWQsIHZhbHVlcyBhbGxvd2VkIGFyZSAnYXNjJywgJ2Rlc2MnLCAnYXNjZW5kaW5nJywgJ2Rlc2NlbmRpbmcnLCAxLCBhbmQgLTEuXG4gKlxuICogSWYgYSBzdHJpbmcgaXMgcGFzc2VkLCBpdCBtdXN0IGJlIGEgc3BhY2UgZGVsaW1pdGVkIGxpc3Qgb2YgcGF0aCBuYW1lcy4gVGhlIHNvcnQgb3JkZXIgb2YgZWFjaCBwYXRoIGlzIGFzY2VuZGluZyB1bmxlc3MgdGhlIHBhdGggbmFtZSBpcyBwcmVmaXhlZCB3aXRoIGAtYCB3aGljaCB3aWxsIGJlIHRyZWF0ZWQgYXMgZGVzY2VuZGluZy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIHRoZXNlIGFyZSBlcXVpdmFsZW50XG4gKiAgICAgcXVlcnkuc29ydCh7IGZpZWxkOiAnYXNjJywgdGVzdDogLTEgfSk7XG4gKiAgICAgcXVlcnkuc29ydCgnZmllbGQgLXRlc3QnKTtcbiAqICAgICBxdWVyeS5zb3J0KFtbJ2ZpZWxkJywgMV0sIFsndGVzdCcsIC0xXV0pO1xuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiAgLSBUaGUgYXJyYXkgc3ludGF4IGAuc29ydChbWydmaWVsZCcsIDFdLCBbJ3Rlc3QnLCAtMV1dKWAgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIFttb25nb2RiIGRyaXZlciA+PSAyLjAuNDZdKGh0dHBzOi8vZ2l0aHViLmNvbS9tb25nb2RiL25vZGUtbW9uZ29kYi1uYXRpdmUvYmxvYi8yLjEvSElTVE9SWS5tZCMyMDQ2LTIwMTUtMTAtMTUpLlxuICogIC0gQ2Fubm90IGJlIHVzZWQgd2l0aCBgZGlzdGluY3QoKWBcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8QXJyYXl9IGFyZ1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbihhcmcpIHtcbiAgaWYgKCFhcmcpIHJldHVybiB0aGlzO1xuICBsZXQgaSwgbGVuLCBmaWVsZDtcblxuICB0aGlzLl92YWxpZGF0ZSgnc29ydCcpO1xuXG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgYXJnO1xuXG4gIC8vIC5zb3J0KFtbJ2ZpZWxkJywgMV0sIFsndGVzdCcsIC0xXV0pXG4gIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICBsZW4gPSBhcmcubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhcmcubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcmdbaV0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzb3J0KCkgYXJndW1lbnQsIG11c3QgYmUgYXJyYXkgb2YgYXJyYXlzJyk7XG4gICAgICB9XG4gICAgICBfcHVzaEFycih0aGlzLm9wdGlvbnMsIGFyZ1tpXVswXSwgYXJnW2ldWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyAuc29ydCgnZmllbGQgLXRlc3QnKVxuICBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCAmJiAnc3RyaW5nJyA9PSB0eXBlKSB7XG4gICAgYXJnID0gYXJnLnNwbGl0KC9cXHMrLyk7XG4gICAgbGVuID0gYXJnLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGZpZWxkID0gYXJnW2ldO1xuICAgICAgaWYgKCFmaWVsZCkgY29udGludWU7XG4gICAgICBjb25zdCBhc2NlbmQgPSAnLScgPT0gZmllbGRbMF0gPyAtMSA6IDE7XG4gICAgICBpZiAoYXNjZW5kID09PSAtMSkgZmllbGQgPSBmaWVsZC5zdWJzdHJpbmcoMSk7XG4gICAgICBwdXNoKHRoaXMub3B0aW9ucywgZmllbGQsIGFzY2VuZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyAuc29ydCh7IGZpZWxkOiAxLCB0ZXN0OiAtMSB9KVxuICBpZiAodXRpbHMuaXNPYmplY3QoYXJnKSkge1xuICAgIGNvbnN0IGtleXMgPSB1dGlscy5rZXlzKGFyZyk7XG4gICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGZpZWxkID0ga2V5c1tpXTtcbiAgICAgIHB1c2godGhpcy5vcHRpb25zLCBmaWVsZCwgYXJnW2ZpZWxkXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAodHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgYXJnIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgX3B1c2hNYXAodGhpcy5vcHRpb25zLCBhcmcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc29ydCgpIGFyZ3VtZW50LiBNdXN0IGJlIGEgc3RyaW5nLCBvYmplY3QsIG9yIGFycmF5LicpO1xufTtcblxuLyohXG4gKiBAaWdub3JlXG4gKi9cblxuY29uc3QgX3ZhbGlkU29ydFZhbHVlID0ge1xuICAxOiAxLFxuICAnLTEnOiAtMSxcbiAgYXNjOiAxLFxuICBhc2NlbmRpbmc6IDEsXG4gIGRlc2M6IC0xLFxuICBkZXNjZW5kaW5nOiAtMVxufTtcblxuZnVuY3Rpb24gcHVzaChvcHRzLCBmaWVsZCwgdmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0cy5zb3J0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NhblxcJ3QgbWl4IHNvcnQgc3ludGF4ZXMuIFVzZSBlaXRoZXIgYXJyYXkgb3Igb2JqZWN0OicgK1xuICAgICAgJ1xcbi0gYC5zb3J0KFtbXFwnZmllbGRcXCcsIDFdLCBbXFwndGVzdFxcJywgLTFdXSlgJyArXG4gICAgICAnXFxuLSBgLnNvcnQoeyBmaWVsZDogMSwgdGVzdDogLTEgfSlgJyk7XG4gIH1cblxuICBsZXQgcztcbiAgaWYgKHZhbHVlICYmIHZhbHVlLiRtZXRhKSB7XG4gICAgcyA9IG9wdHMuc29ydCB8fCAob3B0cy5zb3J0ID0ge30pO1xuICAgIHNbZmllbGRdID0geyAkbWV0YTogdmFsdWUuJG1ldGEgfTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzID0gb3B0cy5zb3J0IHx8IChvcHRzLnNvcnQgPSB7fSk7XG4gIGxldCB2YWwgPSBTdHJpbmcodmFsdWUgfHwgMSkudG9Mb3dlckNhc2UoKTtcbiAgdmFsID0gX3ZhbGlkU29ydFZhbHVlW3ZhbF07XG4gIGlmICghdmFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHNvcnQgdmFsdWU6IHsgJyArIGZpZWxkICsgJzogJyArIHZhbHVlICsgJyB9Jyk7XG5cbiAgc1tmaWVsZF0gPSB2YWw7XG59XG5cbmZ1bmN0aW9uIF9wdXNoQXJyKG9wdHMsIGZpZWxkLCB2YWx1ZSkge1xuICBvcHRzLnNvcnQgPSBvcHRzLnNvcnQgfHwgW107XG4gIGlmICghQXJyYXkuaXNBcnJheShvcHRzLnNvcnQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2FuXFwndCBtaXggc29ydCBzeW50YXhlcy4gVXNlIGVpdGhlciBhcnJheSBvciBvYmplY3Q6JyArXG4gICAgICAnXFxuLSBgLnNvcnQoW1tcXCdmaWVsZFxcJywgMV0sIFtcXCd0ZXN0XFwnLCAtMV1dKWAnICtcbiAgICAgICdcXG4tIGAuc29ydCh7IGZpZWxkOiAxLCB0ZXN0OiAtMSB9KWAnKTtcbiAgfVxuXG4gIGxldCB2YWwgPSBTdHJpbmcodmFsdWUgfHwgMSkudG9Mb3dlckNhc2UoKTtcbiAgdmFsID0gX3ZhbGlkU29ydFZhbHVlW3ZhbF07XG4gIGlmICghdmFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHNvcnQgdmFsdWU6IFsgJyArIGZpZWxkICsgJywgJyArIHZhbHVlICsgJyBdJyk7XG5cbiAgb3B0cy5zb3J0LnB1c2goW2ZpZWxkLCB2YWxdKTtcbn1cblxuZnVuY3Rpb24gX3B1c2hNYXAob3B0cywgbWFwKSB7XG4gIG9wdHMuc29ydCA9IG9wdHMuc29ydCB8fCBuZXcgTWFwKCk7XG4gIGlmICghKG9wdHMuc29ydCBpbnN0YW5jZW9mIE1hcCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5cXCd0IG1peCBzb3J0IHN5bnRheGVzLiBVc2UgZWl0aGVyIGFycmF5IG9yICcgK1xuICAgICAgJ29iamVjdCBvciBtYXAgY29uc2lzdGVudGx5Jyk7XG4gIH1cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIGxldCB2YWwgPSBTdHJpbmcodmFsdWUgfHwgMSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSBfdmFsaWRTb3J0VmFsdWVbdmFsXTtcbiAgICBpZiAoIXZhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzb3J0IHZhbHVlOiA8ICcgKyBrZXkgKyAnOiAnICsgdmFsdWUgKyAnID4nKTtcblxuICAgIG9wdHMuc29ydC5zZXQoa2V5LCB2YWwpO1xuICB9KTtcbn1cblxuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgbGltaXQgb3B0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkubGltaXQoMjApXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQG1ldGhvZCBsaW1pdFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWR2YW5jZWQrUXVlcmllcyNBZHZhbmNlZFF1ZXJpZXMtJTdCJTdCbGltaXQlMjglMjklN0QlN0RcbiAqIEBhcGkgcHVibGljXG4gKi9cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBza2lwIG9wdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LnNraXAoMTAwKS5saW1pdCgyMClcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogQ2Fubm90IGJlIHVzZWQgd2l0aCBgZGlzdGluY3QoKWBcbiAqXG4gKiBAbWV0aG9kIHNraXBcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQHNlZSBtb25nb2RiIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FkdmFuY2VkK1F1ZXJpZXMjQWR2YW5jZWRRdWVyaWVzLSU3QiU3QnNraXAlMjglMjklN0QlN0RcbiAqIEBhcGkgcHVibGljXG4gKi9cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBiYXRjaFNpemUgb3B0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuYmF0Y2hTaXplKDEwMClcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogQ2Fubm90IGJlIHVzZWQgd2l0aCBgZGlzdGluY3QoKWBcbiAqXG4gKiBAbWV0aG9kIGJhdGNoU2l6ZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWR2YW5jZWQrUXVlcmllcyNBZHZhbmNlZFF1ZXJpZXMtJTdCJTdCYmF0Y2hTaXplJTI4JTI5JTdEJTdEXG4gKiBAYXBpIHB1YmxpY1xuICovXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYGNvbW1lbnRgIG9wdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmNvbW1lbnQoJ2xvZ2luIHF1ZXJ5JylcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogQ2Fubm90IGJlIHVzZWQgd2l0aCBgZGlzdGluY3QoKWBcbiAqXG4gKiBAbWV0aG9kIGNvbW1lbnRcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQHNlZSBtb25nb2RiIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FkdmFuY2VkK1F1ZXJpZXMjQWR2YW5jZWRRdWVyaWVzLSUyNGNvbW1lbnRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyohXG4gKiBsaW1pdCwgc2tpcCwgYmF0Y2hTaXplLCBjb21tZW50XG4gKlxuICogU2V0cyB0aGVzZSBhc3NvY2lhdGVkIG9wdGlvbnMuXG4gKlxuICogICAgIHF1ZXJ5LmNvbW1lbnQoJ2ZlZWQgcXVlcnknKTtcbiAqL1xuXG5bJ2xpbWl0JywgJ3NraXAnLCAnYmF0Y2hTaXplJywgJ2NvbW1lbnQnXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBRdWVyeS5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHYpIHtcbiAgICB0aGlzLl92YWxpZGF0ZShtZXRob2QpO1xuICAgIHRoaXMub3B0aW9uc1ttZXRob2RdID0gdjtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn0pO1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgbWF4VGltZU1TIG9wdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5Lm1heFRpbWUoMTAwKVxuICogICAgIHF1ZXJ5Lm1heFRpbWVNUygxMDApXG4gKlxuICogQG1ldGhvZCBtYXhUaW1lXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHNlZSBtb25nb2RiIGh0dHA6Ly9kb2NzLm1vbmdvZGIub3JnL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbWV0YS9tYXhUaW1lTVMvI29wLl9TX21heFRpbWVNU1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubWF4VGltZSA9IFF1ZXJ5LnByb3RvdHlwZS5tYXhUaW1lTVMgPSBmdW5jdGlvbihtcykge1xuICB0aGlzLl92YWxpZGF0ZSgnbWF4VGltZScpO1xuICB0aGlzLm9wdGlvbnMubWF4VGltZU1TID0gbXM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHF1ZXJ5IGhpbnRzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuaGludCh7IGluZGV4QTogMSwgaW5kZXhCOiAtMX0pO1xuICogICAgIHF1ZXJ5LmhpbnQoJ2luZGV4QV8xX2luZGV4Ql8xJyk7XG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSB2YWwgYSBoaW50IG9iamVjdCBvciB0aGUgaW5kZXggbmFtZVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZHZhbmNlZCtRdWVyaWVzI0FkdmFuY2VkUXVlcmllcy0lMjRoaW50XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5oaW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICgwID09PSBhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcztcblxuICB0aGlzLl92YWxpZGF0ZSgnaGludCcpO1xuXG4gIGNvbnN0IGFyZyA9IGFyZ3VtZW50c1swXTtcbiAgaWYgKHV0aWxzLmlzT2JqZWN0KGFyZykpIHtcbiAgICBjb25zdCBoaW50ID0gdGhpcy5vcHRpb25zLmhpbnQgfHwgKHRoaXMub3B0aW9ucy5oaW50ID0ge30pO1xuXG4gICAgLy8gbXVzdCBrZWVwIG9iamVjdCBrZXlzIGluIG9yZGVyIHNvIGRvbid0IHVzZSBPYmplY3Qua2V5cygpXG4gICAgZm9yIChjb25zdCBrIGluIGFyZykge1xuICAgICAgaGludFtrXSA9IGFyZ1trXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLm9wdGlvbnMuaGludCA9IGFyZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGludC4gJyArIGFyZyk7XG59O1xuXG4vKipcbiAqIFJlcXVlc3RzIGFja25vd2xlZGdlbWVudCB0aGF0IHRoaXMgb3BlcmF0aW9uIGhhcyBiZWVuIHBlcnNpc3RlZCB0byBNb25nb0RCJ3NcbiAqIG9uLWRpc2sgam91cm5hbC5cbiAqIFRoaXMgb3B0aW9uIGlzIG9ubHkgdmFsaWQgZm9yIG9wZXJhdGlvbnMgdGhhdCB3cml0ZSB0byB0aGUgZGF0YWJhc2U6XG4gKlxuICogLSBgZGVsZXRlT25lKClgXG4gKiAtIGBkZWxldGVNYW55KClgXG4gKiAtIGBmaW5kT25lQW5kRGVsZXRlKClgXG4gKiAtIGBmaW5kT25lQW5kVXBkYXRlKClgXG4gKiAtIGB1cGRhdGVPbmUoKWBcbiAqIC0gYHVwZGF0ZU1hbnkoKWBcbiAqXG4gKiBEZWZhdWx0cyB0byB0aGUgYGpgIHZhbHVlIGlmIGl0IGlzIHNwZWNpZmllZCBpbiB3cml0ZUNvbmNlcm4gb3B0aW9uc1xuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbXF1ZXJ5KCkudygyKS5qKHRydWUpLnd0aW1lb3V0KDIwMDApO1xuICpcbiAqIEBtZXRob2QgalxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8jai1vcHRpb25cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5qID0gZnVuY3Rpb24gaih2YWwpIHtcbiAgdGhpcy5vcHRpb25zLmogPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzbGF2ZU9rIG9wdGlvbi4gX0RlcHJlY2F0ZWRfIGluIE1vbmdvREIgMi4yIGluIGZhdm9yIG9mIHJlYWQgcHJlZmVyZW5jZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5zbGF2ZU9rKCkgLy8gdHJ1ZVxuICogICAgIHF1ZXJ5LnNsYXZlT2sodHJ1ZSlcbiAqICAgICBxdWVyeS5zbGF2ZU9rKGZhbHNlKVxuICpcbiAqIEBkZXByZWNhdGVkIHVzZSByZWFkKCkgcHJlZmVyZW5jZXMgaW5zdGVhZCBpZiBvbiBtb25nb2RiID49IDIuMlxuICogQHBhcmFtIHtCb29sZWFufSB2IGRlZmF1bHRzIHRvIHRydWVcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vZG9jcy5tb25nb2RiLm9yZy9tYW51YWwvYXBwbGljYXRpb25zL3JlcGxpY2F0aW9uLyNyZWFkLXByZWZlcmVuY2VcbiAqIEBzZWUgcmVhZCgpXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2xhdmVPayA9IGZ1bmN0aW9uKHYpIHtcbiAgdGhpcy5vcHRpb25zLnNsYXZlT2sgPSBhcmd1bWVudHMubGVuZ3RoID8gISF2IDogdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHJlYWRQcmVmZXJlbmNlIG9wdGlvbiBmb3IgdGhlIHF1ZXJ5LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgncHJpbWFyeScpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgncCcpICAvLyBzYW1lIGFzIHByaW1hcnlcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgncHJpbWFyeVByZWZlcnJlZCcpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgncHAnKSAvLyBzYW1lIGFzIHByaW1hcnlQcmVmZXJyZWRcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgnc2Vjb25kYXJ5JylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdzJykgIC8vIHNhbWUgYXMgc2Vjb25kYXJ5XG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3NlY29uZGFyeVByZWZlcnJlZCcpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgnc3AnKSAvLyBzYW1lIGFzIHNlY29uZGFyeVByZWZlcnJlZFxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCduZWFyZXN0JylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCduJykgIC8vIHNhbWUgYXMgbmVhcmVzdFxuICpcbiAqICAgICAvLyB5b3UgY2FuIGFsc28gdXNlIG1vbmdvZGIuUmVhZFByZWZlcmVuY2UgY2xhc3MgdG8gYWxzbyBzcGVjaWZ5IHRhZ3NcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKG1vbmdvZGIuUmVhZFByZWZlcmVuY2UoJ3NlY29uZGFyeScsIFt7IGRjOidzZicsIHM6IDEgfSx7IGRjOidtYScsIHM6IDIgfV0pKVxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5zZXRSZWFkUHJlZmVyZW5jZSgncHJpbWFyeScpIC8vIGFsaWFzIG9mIC5yZWFkKClcbiAqXG4gKiAjIyMjIFByZWZlcmVuY2VzOlxuICpcbiAqICAgICBwcmltYXJ5IC0gKGRlZmF1bHQpICBSZWFkIGZyb20gcHJpbWFyeSBvbmx5LiBPcGVyYXRpb25zIHdpbGwgcHJvZHVjZSBhbiBlcnJvciBpZiBwcmltYXJ5IGlzIHVuYXZhaWxhYmxlLiBDYW5ub3QgYmUgY29tYmluZWQgd2l0aCB0YWdzLlxuICogICAgIHNlY29uZGFyeSAgICAgICAgICAgIFJlYWQgZnJvbSBzZWNvbmRhcnkgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgZXJyb3IuXG4gKiAgICAgcHJpbWFyeVByZWZlcnJlZCAgICAgUmVhZCBmcm9tIHByaW1hcnkgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgYSBzZWNvbmRhcnkuXG4gKiAgICAgc2Vjb25kYXJ5UHJlZmVycmVkICAgUmVhZCBmcm9tIGEgc2Vjb25kYXJ5IGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHJlYWQgZnJvbSB0aGUgcHJpbWFyeS5cbiAqICAgICBuZWFyZXN0ICAgICAgICAgICAgICBBbGwgb3BlcmF0aW9ucyByZWFkIGZyb20gYW1vbmcgdGhlIG5lYXJlc3QgY2FuZGlkYXRlcywgYnV0IHVubGlrZSBvdGhlciBtb2RlcywgdGhpcyBvcHRpb24gd2lsbCBpbmNsdWRlIGJvdGggdGhlIHByaW1hcnkgYW5kIGFsbCBzZWNvbmRhcmllcyBpbiB0aGUgcmFuZG9tIHNlbGVjdGlvbi5cbiAqXG4gKiBBbGlhc2VzXG4gKlxuICogICAgIHAgICBwcmltYXJ5XG4gKiAgICAgcHAgIHByaW1hcnlQcmVmZXJyZWRcbiAqICAgICBzICAgc2Vjb25kYXJ5XG4gKiAgICAgc3AgIHNlY29uZGFyeVByZWZlcnJlZFxuICogICAgIG4gICBuZWFyZXN0XG4gKlxuICogUmVhZCBtb3JlIGFib3V0IGhvdyB0byB1c2UgcmVhZCBwcmVmZXJlbmNlcyBbaGVyZV0oaHR0cDovL2RvY3MubW9uZ29kYi5vcmcvbWFudWFsL2FwcGxpY2F0aW9ucy9yZXBsaWNhdGlvbi8jcmVhZC1wcmVmZXJlbmNlKSBhbmQgW2hlcmVdKGh0dHA6Ly9tb25nb2RiLmdpdGh1Yi5jb20vbm9kZS1tb25nb2RiLW5hdGl2ZS9kcml2ZXItYXJ0aWNsZXMvYW5pbnRyb2R1Y3Rpb250bzFfMWFuZDJfMi5odG1sI3JlYWQtcHJlZmVyZW5jZXMpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFJlYWRQcmVmZXJlbmNlfSBwcmVmIG9uZSBvZiB0aGUgbGlzdGVkIHByZWZlcmVuY2Ugb3B0aW9ucyBvciB0aGVpciBhbGlhc2VzXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL2RvY3MubW9uZ29kYi5vcmcvbWFudWFsL2FwcGxpY2F0aW9ucy9yZXBsaWNhdGlvbi8jcmVhZC1wcmVmZXJlbmNlXG4gKiBAc2VlIGRyaXZlciBodHRwOi8vbW9uZ29kYi5naXRodWIuY29tL25vZGUtbW9uZ29kYi1uYXRpdmUvZHJpdmVyLWFydGljbGVzL2FuaW50cm9kdWN0aW9udG8xXzFhbmQyXzIuaHRtbCNyZWFkLXByZWZlcmVuY2VzXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUucmVhZCA9IFF1ZXJ5LnByb3RvdHlwZS5zZXRSZWFkUHJlZmVyZW5jZSA9IGZ1bmN0aW9uKHByZWYpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmICFRdWVyeS5wcm90b3R5cGUucmVhZC5kZXByZWNhdGlvbldhcm5pbmdJc3N1ZWQpIHtcbiAgICBjb25zb2xlLmVycm9yKCdEZXByZWNhdGlvbiB3YXJuaW5nOiBcXCd0YWdzXFwnIGFyZ3VtZW50IGlzIG5vdCBzdXBwb3J0ZWQgYW55bW9yZSBpbiBRdWVyeS5yZWFkKCkgbWV0aG9kLiBQbGVhc2UgdXNlIG1vbmdvZGIuUmVhZFByZWZlcmVuY2Ugb2JqZWN0IGluc3RlYWQuJyk7XG4gICAgUXVlcnkucHJvdG90eXBlLnJlYWQuZGVwcmVjYXRpb25XYXJuaW5nSXNzdWVkID0gdHJ1ZTtcbiAgfVxuICB0aGlzLm9wdGlvbnMucmVhZFByZWZlcmVuY2UgPSB1dGlscy5yZWFkUHJlZihwcmVmKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHJlYWRDb25jZXJuIG9wdGlvbiBmb3IgdGhlIHF1ZXJ5LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ2xvY2FsJylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignbCcpICAvLyBzYW1lIGFzIGxvY2FsXG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdhdmFpbGFibGUnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdhJykgIC8vIHNhbWUgYXMgYXZhaWxhYmxlXG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdtYWpvcml0eScpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ20nKSAgLy8gc2FtZSBhcyBtYWpvcml0eVxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignbGluZWFyaXphYmxlJylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignbHonKSAvLyBzYW1lIGFzIGxpbmVhcml6YWJsZVxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2Vybignc25hcHNob3QnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdzJykgIC8vIHNhbWUgYXMgc25hcHNob3RcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucigncycpIC8vIHIgaXMgYWxpYXMgb2YgcmVhZENvbmNlcm5cbiAqXG4gKlxuICogIyMjIyBSZWFkIENvbmNlcm4gTGV2ZWw6XG4gKlxuICogICAgIGxvY2FsICAgICAgICAgTW9uZ29EQiAzLjIrIFRoZSBxdWVyeSByZXR1cm5zIGZyb20gdGhlIGluc3RhbmNlIHdpdGggbm8gZ3VhcmFudGVlIGd1YXJhbnRlZSB0aGF0IHRoZSBkYXRhIGhhcyBiZWVuIHdyaXR0ZW4gdG8gYSBtYWpvcml0eSBvZiB0aGUgcmVwbGljYSBzZXQgbWVtYmVycyAoaS5lLiBtYXkgYmUgcm9sbGVkIGJhY2spLlxuICogICAgIGF2YWlsYWJsZSAgICAgTW9uZ29EQiAzLjYrIFRoZSBxdWVyeSByZXR1cm5zIGZyb20gdGhlIGluc3RhbmNlIHdpdGggbm8gZ3VhcmFudGVlIGd1YXJhbnRlZSB0aGF0IHRoZSBkYXRhIGhhcyBiZWVuIHdyaXR0ZW4gdG8gYSBtYWpvcml0eSBvZiB0aGUgcmVwbGljYSBzZXQgbWVtYmVycyAoaS5lLiBtYXkgYmUgcm9sbGVkIGJhY2spLlxuICogICAgIG1ham9yaXR5ICAgICAgTW9uZ29EQiAzLjIrIFRoZSBxdWVyeSByZXR1cm5zIHRoZSBkYXRhIHRoYXQgaGFzIGJlZW4gYWNrbm93bGVkZ2VkIGJ5IGEgbWFqb3JpdHkgb2YgdGhlIHJlcGxpY2Egc2V0IG1lbWJlcnMuIFRoZSBkb2N1bWVudHMgcmV0dXJuZWQgYnkgdGhlIHJlYWQgb3BlcmF0aW9uIGFyZSBkdXJhYmxlLCBldmVuIGluIHRoZSBldmVudCBvZiBmYWlsdXJlLlxuICogICAgIGxpbmVhcml6YWJsZSAgTW9uZ29EQiAzLjQrIFRoZSBxdWVyeSByZXR1cm5zIGRhdGEgdGhhdCByZWZsZWN0cyBhbGwgc3VjY2Vzc2Z1bCBtYWpvcml0eS1hY2tub3dsZWRnZWQgd3JpdGVzIHRoYXQgY29tcGxldGVkIHByaW9yIHRvIHRoZSBzdGFydCBvZiB0aGUgcmVhZCBvcGVyYXRpb24uIFRoZSBxdWVyeSBtYXkgd2FpdCBmb3IgY29uY3VycmVudGx5IGV4ZWN1dGluZyB3cml0ZXMgdG8gcHJvcGFnYXRlIHRvIGEgbWFqb3JpdHkgb2YgcmVwbGljYSBzZXQgbWVtYmVycyBiZWZvcmUgcmV0dXJuaW5nIHJlc3VsdHMuXG4gKiAgICAgc25hcHNob3QgICAgICBNb25nb0RCIDQuMCsgT25seSBhdmFpbGFibGUgZm9yIG9wZXJhdGlvbnMgd2l0aGluIG11bHRpLWRvY3VtZW50IHRyYW5zYWN0aW9ucy4gVXBvbiB0cmFuc2FjdGlvbiBjb21taXQgd2l0aCB3cml0ZSBjb25jZXJuIFwibWFqb3JpdHlcIiwgdGhlIHRyYW5zYWN0aW9uIG9wZXJhdGlvbnMgYXJlIGd1YXJhbnRlZWQgdG8gaGF2ZSByZWFkIGZyb20gYSBzbmFwc2hvdCBvZiBtYWpvcml0eS1jb21taXR0ZWQgZGF0YS5cbiAqXG4gKiBBbGlhc2VzXG4gKlxuICogICAgIGwgICBsb2NhbFxuICogICAgIGEgICBhdmFpbGFibGVcbiAqICAgICBtICAgbWFqb3JpdHlcbiAqICAgICBseiAgbGluZWFyaXphYmxlXG4gKiAgICAgcyAgIHNuYXBzaG90XG4gKlxuICogUmVhZCBtb3JlIGFib3V0IGhvdyB0byB1c2UgcmVhZCBjb25jZXJuIFtoZXJlXShodHRwczovL2RvY3MubW9uZ29kYi5jb20vbWFudWFsL3JlZmVyZW5jZS9yZWFkLWNvbmNlcm4vKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbGV2ZWwgb25lIG9mIHRoZSBsaXN0ZWQgcmVhZCBjb25jZXJuIGxldmVsIG9yIHRoZWlyIGFsaWFzZXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL2RvY3MubW9uZ29kYi5jb20vbWFudWFsL3JlZmVyZW5jZS9yZWFkLWNvbmNlcm4vXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUucmVhZENvbmNlcm4gPSBRdWVyeS5wcm90b3R5cGUuciA9IGZ1bmN0aW9uKGxldmVsKSB7XG4gIHRoaXMub3B0aW9ucy5yZWFkQ29uY2VybiA9IHV0aWxzLnJlYWRDb25jZXJuKGxldmVsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGFpbGFibGUgb3B0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkudGFpbGFibGUoKSA8PT0gdHJ1ZVxuICogICAgIHF1ZXJ5LnRhaWxhYmxlKHRydWUpXG4gKiAgICAgcXVlcnkudGFpbGFibGUoZmFsc2UpXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB2IGRlZmF1bHRzIHRvIHRydWVcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9UYWlsYWJsZStDdXJzb3JzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS50YWlsYWJsZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl92YWxpZGF0ZSgndGFpbGFibGUnKTtcblxuICB0aGlzLm9wdGlvbnMudGFpbGFibGUgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgPyAhIWFyZ3VtZW50c1swXVxuICAgIDogdHJ1ZTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBgbW9uZ29kYCBzZXJ2ZXJzLCBvciB0YWcgc2V0IG9mIGBtb25nb2RgIHNlcnZlcnMsXG4gKiB0aGF0IG11c3QgYWNrbm93bGVkZ2UgdGhpcyB3cml0ZSBiZWZvcmUgdGhpcyB3cml0ZSBpcyBjb25zaWRlcmVkIHN1Y2Nlc3NmdWwuXG4gKiBUaGlzIG9wdGlvbiBpcyBvbmx5IHZhbGlkIGZvciBvcGVyYXRpb25zIHRoYXQgd3JpdGUgdG8gdGhlIGRhdGFiYXNlOlxuICpcbiAqIC0gYGRlbGV0ZU9uZSgpYFxuICogLSBgZGVsZXRlTWFueSgpYFxuICogLSBgZmluZE9uZUFuZERlbGV0ZSgpYFxuICogLSBgZmluZE9uZUFuZFVwZGF0ZSgpYFxuICogLSBgdXBkYXRlT25lKClgXG4gKiAtIGB1cGRhdGVNYW55KClgXG4gKlxuICogRGVmYXVsdHMgdG8gdGhlIGB3YCB2YWx1ZSBpZiBpdCBpcyBzcGVjaWZpZWQgaW4gd3JpdGVDb25jZXJuIG9wdGlvbnNcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1xdWVyeSgpLndyaXRlQ29uY2VybigwKVxuICogICAgIG1xdWVyeSgpLndyaXRlQ29uY2VybigxKVxuICogICAgIG1xdWVyeSgpLndyaXRlQ29uY2Vybih7IHc6IDEsIGo6IHRydWUsIHd0aW1lb3V0OiAyMDAwIH0pXG4gKiAgICAgbXF1ZXJ5KCkud3JpdGVDb25jZXJuKCdtYWpvcml0eScpXG4gKiAgICAgbXF1ZXJ5KCkud3JpdGVDb25jZXJuKCdtJykgLy8gc2FtZSBhcyBtYWpvcml0eVxuICogICAgIG1xdWVyeSgpLndyaXRlQ29uY2VybigndGFnU2V0TmFtZScpIC8vIGlmIHRoZSB0YWcgc2V0IGlzICdtJywgdXNlIC53cml0ZUNvbmNlcm4oeyB3OiAnbScgfSkgaW5zdGVhZFxuICogICAgIG1xdWVyeSgpLncoMSkgLy8gdyBpcyBhbGlhcyBvZiB3cml0ZUNvbmNlcm5cbiAqXG4gKiBAbWV0aG9kIHdyaXRlQ29uY2VyblxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfG51bWJlcnxvYmplY3R9IGNvbmNlcm4gMCBmb3IgZmlyZS1hbmQtZm9yZ2V0LCAxIGZvciBhY2tub3dsZWRnZWQgYnkgb25lIHNlcnZlciwgJ21ham9yaXR5JyBmb3IgbWFqb3JpdHkgb2YgdGhlIHJlcGxpY2Egc2V0LCBvciBbYW55IG9mIHRoZSBtb3JlIGFkdmFuY2VkIG9wdGlvbnNdKGh0dHBzOi8vZG9jcy5tb25nb2RiLmNvbS9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI3ctb3B0aW9uKS5cbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL2RvY3MubW9uZ29kYi5jb20vbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyN3LW9wdGlvblxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLndyaXRlQ29uY2VybiA9IFF1ZXJ5LnByb3RvdHlwZS53ID0gZnVuY3Rpb24gd3JpdGVDb25jZXJuKGNvbmNlcm4pIHtcbiAgaWYgKCdvYmplY3QnID09PSB0eXBlb2YgY29uY2Vybikge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGNvbmNlcm4uaikgdGhpcy5vcHRpb25zLmogPSBjb25jZXJuLmo7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgY29uY2Vybi53KSB0aGlzLm9wdGlvbnMudyA9IGNvbmNlcm4udztcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBjb25jZXJuLnd0aW1lb3V0KSB0aGlzLm9wdGlvbnMud3RpbWVvdXQgPSBjb25jZXJuLnd0aW1lb3V0O1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy53ID0gJ20nID09PSBjb25jZXJuID8gJ21ham9yaXR5JyA6IGNvbmNlcm47XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIHRpbWUgbGltaXQsIGluIG1pbGxpc2Vjb25kcywgZm9yIHRoZSB3cml0ZSBjb25jZXJuLlxuICogSWYgYG1zID4gMWAsIGl0IGlzIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBmb3IgdGhpcyB3cml0ZVxuICogdG8gcHJvcGFnYXRlIHRocm91Z2ggdGhlIHJlcGxpY2Egc2V0IGJlZm9yZSB0aGlzIG9wZXJhdGlvbiBmYWlscy5cbiAqIFRoZSBkZWZhdWx0IGlzIGAwYCwgd2hpY2ggbWVhbnMgbm8gdGltZW91dC5cbiAqXG4gKiBUaGlzIG9wdGlvbiBpcyBvbmx5IHZhbGlkIGZvciBvcGVyYXRpb25zIHRoYXQgd3JpdGUgdG8gdGhlIGRhdGFiYXNlOlxuICpcbiAqIC0gYGRlbGV0ZU9uZSgpYFxuICogLSBgZGVsZXRlTWFueSgpYFxuICogLSBgZmluZE9uZUFuZERlbGV0ZSgpYFxuICogLSBgZmluZE9uZUFuZFVwZGF0ZSgpYFxuICogLSBgdXBkYXRlT25lKClgXG4gKiAtIGB1cGRhdGVNYW55KClgXG4gKlxuICogRGVmYXVsdHMgdG8gYHd0aW1lb3V0YCB2YWx1ZSBpZiBpdCBpcyBzcGVjaWZpZWQgaW4gd3JpdGVDb25jZXJuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBtcXVlcnkoKS53KDIpLmoodHJ1ZSkud3RpbWVvdXQoMjAwMClcbiAqXG4gKiBAbWV0aG9kIHd0aW1lb3V0XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IG1zIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdFxuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vZG9jcy5tb25nb2RiLmNvbS9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI3d0aW1lb3V0XG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUud3RpbWVvdXQgPSBRdWVyeS5wcm90b3R5cGUud1RpbWVvdXQgPSBmdW5jdGlvbiB3dGltZW91dChtcykge1xuICB0aGlzLm9wdGlvbnMud3RpbWVvdXQgPSBtcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1lcmdlcyBhbm90aGVyIFF1ZXJ5IG9yIGNvbmRpdGlvbnMgb2JqZWN0IGludG8gdGhpcyBvbmUuXG4gKlxuICogV2hlbiBhIFF1ZXJ5IGlzIHBhc3NlZCwgY29uZGl0aW9ucywgZmllbGQgc2VsZWN0aW9uIGFuZCBvcHRpb25zIGFyZSBtZXJnZWQuXG4gKlxuICogQHBhcmFtIHtRdWVyeXxPYmplY3R9IHNvdXJjZVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgaWYgKCFzb3VyY2UpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgaWYgKCFRdWVyeS5jYW5NZXJnZShzb3VyY2UpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQuIEV4cGVjdGVkIGluc3RhbmNlb2YgbXF1ZXJ5IG9yIHBsYWluIG9iamVjdCcpO1xuXG4gIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBRdWVyeSkge1xuICAgIC8vIGlmIHNvdXJjZSBoYXMgYSBmZWF0dXJlLCBhcHBseSBpdCB0byBvdXJzZWx2ZXNcblxuICAgIGlmIChzb3VyY2UuX2NvbmRpdGlvbnMpIHtcbiAgICAgIHV0aWxzLm1lcmdlKHRoaXMuX2NvbmRpdGlvbnMsIHNvdXJjZS5fY29uZGl0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZS5fZmllbGRzKSB7XG4gICAgICB0aGlzLl9maWVsZHMgfHwgKHRoaXMuX2ZpZWxkcyA9IHt9KTtcbiAgICAgIHV0aWxzLm1lcmdlKHRoaXMuX2ZpZWxkcywgc291cmNlLl9maWVsZHMpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2Uub3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zIHx8ICh0aGlzLm9wdGlvbnMgPSB7fSk7XG4gICAgICB1dGlscy5tZXJnZSh0aGlzLm9wdGlvbnMsIHNvdXJjZS5vcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlLl91cGRhdGVEb2MpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURvYyB8fCAodGhpcy5fdXBkYXRlRG9jID0ge30pO1xuICAgICAgdXRpbHMubWVyZ2VDbG9uZSh0aGlzLl91cGRhdGVEb2MsIHNvdXJjZS5fdXBkYXRlRG9jKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlLl9kaXN0aW5jdERvYykge1xuICAgICAgdGhpcy5fZGlzdGluY3REb2MgPSBzb3VyY2UuX2Rpc3RpbmN0RG9jO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gcGxhaW4gb2JqZWN0XG4gIHV0aWxzLm1lcmdlKHRoaXMuX2NvbmRpdGlvbnMsIHNvdXJjZSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEZpbmRzIGRvY3VtZW50cy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmZpbmQoKVxuICogICAgIGF3YWl0IHF1ZXJ5LmZpbmQoKVxuICogICAgIGF3YWl0IHF1ZXJ5LmZpbmQoeyBuYW1lOiAnQnVybmluZyBMaWdodHMnIH0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtjcml0ZXJpYV0gbW9uZ29kYiBzZWxlY3RvclxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihjcml0ZXJpYSkge1xuICB0aGlzLm9wID0gJ2ZpbmQnO1xuXG4gIGlmIChRdWVyeS5jYW5NZXJnZShjcml0ZXJpYSkpIHtcbiAgICB0aGlzLm1lcmdlKGNyaXRlcmlhKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGBmaW5kYCBRdWVyeVxuICogQHJldHVybnMgdGhlIHJlc3VsdFxuICovXG5RdWVyeS5wcm90b3R5cGUuX2ZpbmQgPSBhc3luYyBmdW5jdGlvbiBfZmluZCgpIHtcbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zO1xuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcblxuICBpZiAodGhpcy4kdXNlUHJvamVjdGlvbikge1xuICAgIG9wdGlvbnMucHJvamVjdGlvbiA9IHRoaXMuX2ZpZWxkc0ZvckV4ZWMoKTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmZpZWxkcyA9IHRoaXMuX2ZpZWxkc0ZvckV4ZWMoKTtcbiAgfVxuXG4gIGRlYnVnKCdfZmluZCcsIHRoaXMuX2NvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWUsIGNvbmRzLCBvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi5maW5kKGNvbmRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcXVlcnkgY3Vyc29yXG4gKlxuICogIyMjIyBFeGFtcGxlczpcbiAqXG4gKiAgICAgcXVlcnkuZmluZCgpLmN1cnNvcigpO1xuICogICAgIHF1ZXJ5LmN1cnNvcih7IG5hbWU6ICdCdXJuaW5nIExpZ2h0cycgfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtjcml0ZXJpYV0gbW9uZ29kYiBzZWxlY3RvclxuICogQHJldHVybiB7T2JqZWN0fSBjdXJzb3JcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmN1cnNvciA9IGZ1bmN0aW9uIGN1cnNvcihjcml0ZXJpYSkge1xuICBpZiAodGhpcy5vcCkge1xuICAgIGlmICh0aGlzLm9wICE9PSAnZmluZCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJy5jdXJzb3Igb25seSBzdXBwb3J0IC5maW5kIG1ldGhvZCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZpbmQoY3JpdGVyaWEpO1xuICB9XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zO1xuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcblxuICBpZiAodGhpcy4kdXNlUHJvamVjdGlvbikge1xuICAgIG9wdGlvbnMucHJvamVjdGlvbiA9IHRoaXMuX2ZpZWxkc0ZvckV4ZWMoKTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmZpZWxkcyA9IHRoaXMuX2ZpZWxkc0ZvckV4ZWMoKTtcbiAgfVxuXG4gIGRlYnVnKCdmaW5kQ3Vyc29yJywgdGhpcy5fY29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZSwgY29uZHMsIG9wdGlvbnMpO1xuICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi5maW5kQ3Vyc29yKGNvbmRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHF1ZXJ5IGFzIGEgZmluZE9uZSgpIG9wZXJhdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmZpbmRPbmUoKS53aGVyZSgnbmFtZScsIC9eQnVybmluZy8pO1xuICpcbiAqICAgICBxdWVyeS5maW5kT25lKHsgbmFtZTogL15CdXJuaW5nLyB9KVxuICpcbiAqICAgICBhd2FpdCBxdWVyeS5maW5kT25lKHsgbmFtZTogL15CdXJuaW5nLyB9KTsgLy8gZXhlY3V0ZXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxRdWVyeX0gW2NyaXRlcmlhXSBtb25nb2RiIHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZmluZE9uZSA9IGZ1bmN0aW9uKGNyaXRlcmlhKSB7XG4gIHRoaXMub3AgPSAnZmluZE9uZSc7XG5cbiAgaWYgKFF1ZXJ5LmNhbk1lcmdlKGNyaXRlcmlhKSkge1xuICAgIHRoaXMubWVyZ2UoY3JpdGVyaWEpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgYGZpbmRPbmVgIFF1ZXJ5XG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0c1xuICovXG5RdWVyeS5wcm90b3R5cGUuX2ZpbmRPbmUgPSBhc3luYyBmdW5jdGlvbiBfZmluZE9uZSgpIHtcbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zO1xuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcblxuICBpZiAodGhpcy4kdXNlUHJvamVjdGlvbikge1xuICAgIG9wdGlvbnMucHJvamVjdGlvbiA9IHRoaXMuX2ZpZWxkc0ZvckV4ZWMoKTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmZpZWxkcyA9IHRoaXMuX2ZpZWxkc0ZvckV4ZWMoKTtcbiAgfVxuXG4gIGRlYnVnKCdmaW5kT25lJywgdGhpcy5fY29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZSwgY29uZHMsIG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uLmZpbmRPbmUoY29uZHMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBFeGVjdHVlcyB0aGUgcXVlcnkgYXMgYSBjb3VudCgpIG9wZXJhdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmNvdW50KCkud2hlcmUoJ2NvbG9yJywgJ2JsYWNrJykuZXhlYygpO1xuICpcbiAqICAgICBxdWVyeS5jb3VudCh7IGNvbG9yOiAnYmxhY2snIH0pXG4gKlxuICogICAgIGF3YWl0IHF1ZXJ5LmNvdW50KHsgY29sb3I6ICdibGFjaycgfSk7XG4gKlxuICogICAgIGNvbnN0IGRvYyA9IGF3YWl0IHF1ZXJ5LndoZXJlKCdjb2xvcicsICdibGFjaycpLmNvdW50KCk7XG4gKiAgICAgY29uc29sZS5sb2coJ3RoZXJlIGFyZSAlZCBraXR0ZW5zJywgY291bnQpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY3JpdGVyaWFdIG1vbmdvZGIgc2VsZWN0b3JcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWdncmVnYXRpb24jQWdncmVnYXRpb24tQ291bnRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24oY3JpdGVyaWEpIHtcbiAgdGhpcy5vcCA9ICdjb3VudCc7XG4gIHRoaXMuX3ZhbGlkYXRlKCk7XG5cbiAgaWYgKFF1ZXJ5LmNhbk1lcmdlKGNyaXRlcmlhKSkge1xuICAgIHRoaXMubWVyZ2UoY3JpdGVyaWEpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgYGNvdW50YCBRdWVyeVxuICogQHJldHVybnMgdGhlIHJlc3VsdHNcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9jb3VudCA9IGFzeW5jIGZ1bmN0aW9uIF9jb3VudCgpIHtcbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zLFxuICAgICAgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG5cbiAgZGVidWcoJ2NvdW50JywgdGhpcy5fY29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZSwgY29uZHMsIG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uLmNvdW50KGNvbmRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZXMgb3IgZXhlY3V0ZXMgYSBkaXN0aW5jdCgpIG9wZXJhdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGF3YWl0IGRpc3RpbmN0KGNyaXRlcmlhLCBmaWVsZClcbiAqICAgICBkaXN0aW5jdChjcml0ZXJpYSwgZmllbGQpXG4gKiAgICAgYXdhaXQgZGlzdGluY3QoZmllbGQpXG4gKiAgICAgZGlzdGluY3QoZmllbGQpXG4gKiAgICAgYXdhaXQgZGlzdGluY3QoKVxuICogICAgIGRpc3RpbmN0KClcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxRdWVyeX0gW2NyaXRlcmlhXVxuICogQHBhcmFtIHtTdHJpbmd9IFtmaWVsZF1cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWdncmVnYXRpb24jQWdncmVnYXRpb24tRGlzdGluY3RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmRpc3RpbmN0ID0gZnVuY3Rpb24oY3JpdGVyaWEsIGZpZWxkKSB7XG4gIHRoaXMub3AgPSAnZGlzdGluY3QnO1xuICB0aGlzLl92YWxpZGF0ZSgpO1xuXG4gIGlmICghZmllbGQgJiYgdHlwZW9mIGNyaXRlcmlhID09PSAnc3RyaW5nJykge1xuICAgIGZpZWxkID0gY3JpdGVyaWE7XG4gICAgY3JpdGVyaWEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGZpZWxkKSB7XG4gICAgdGhpcy5fZGlzdGluY3REb2MgPSBmaWVsZDtcbiAgfVxuXG4gIGlmIChRdWVyeS5jYW5NZXJnZShjcml0ZXJpYSkpIHtcbiAgICB0aGlzLm1lcmdlKGNyaXRlcmlhKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGBkaXN0aW5jdGAgUXVlcnlcbiAqIEByZXR1cm5zIHRoZSByZXN1bHRzXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fZGlzdGluY3QgPSBhc3luYyBmdW5jdGlvbiBfZGlzdGluY3QoKSB7XG4gIGlmICghdGhpcy5fZGlzdGluY3REb2MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbHVlIGZvciBgZGlzdGluY3RgIGhhcyBiZWVuIGRlY2xhcmVkJyk7XG4gIH1cblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnMsXG4gICAgICBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcblxuICBkZWJ1ZygnZGlzdGluY3QnLCB0aGlzLl9jb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lLCBjb25kcywgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24uZGlzdGluY3QodGhpcy5fZGlzdGluY3REb2MsIGNvbmRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZSBhbmQvb3IgZXhlY3V0ZSB0aGlzIHF1ZXJ5IGFzIGFuIGB1cGRhdGVNYW55KClgIG9wZXJhdGlvbi4gVGhpcyBmdW5jdGlvbiB3aWxsIHVwZGF0ZSBfYWxsXyBkb2N1bWVudHMgdGhhdCBtYXRjaFxuICogYGNyaXRlcmlhYCwgcmF0aGVyIHRoYW4ganVzdCB0aGUgZmlyc3Qgb25lLlxuICpcbiAqIF9BbGwgcGF0aHMgcGFzc2VkIHRoYXQgYXJlIG5vdCAkYXRvbWljIG9wZXJhdGlvbnMgd2lsbCBiZWNvbWUgJHNldCBvcHMuX1xuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gVXBkYXRlIGV2ZXJ5IGRvY3VtZW50IHdob3NlIGB0aXRsZWAgY29udGFpbnMgJ3Rlc3QnXG4gKiAgICAgbXF1ZXJ5KCkudXBkYXRlTWFueSh7IHRpdGxlOiAvdGVzdC8gfSwgeyB5ZWFyOiAyMDE3IH0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtjcml0ZXJpYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbZG9jXSB0aGUgdXBkYXRlIGNvbW1hbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS51cGRhdGVNYW55ID0gZnVuY3Rpb24gdXBkYXRlTWFueShjcml0ZXJpYSwgZG9jLCBvcHRpb25zKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgZG9jID0gY3JpdGVyaWE7XG4gICAgY3JpdGVyaWEgPSBvcHRpb25zID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIF91cGRhdGUodGhpcywgJ3VwZGF0ZU1hbnknLCBjcml0ZXJpYSwgZG9jLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBgdXBkYXRlTWFueWAgUXVlcnlcbiAqIEByZXR1cm5zIHRoZSByZXN1bHRzXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fdXBkYXRlTWFueSA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICByZXR1cm4gX3VwZGF0ZUV4ZWModGhpcywgJ3VwZGF0ZU1hbnknKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZSBhbmQvb3IgZXhlY3V0ZSB0aGlzIHF1ZXJ5IGFzIGFuIGB1cGRhdGVPbmUoKWAgb3BlcmF0aW9uLiBUaGlzIGZ1bmN0aW9uIHdpbGwgX2Fsd2F5c18gdXBkYXRlIGp1c3Qgb25lIGRvY3VtZW50LFxuICogcmVnYXJkbGVzcyBvZiB0aGUgYG11bHRpYCBvcHRpb24uXG4gKlxuICogX0FsbCBwYXRocyBwYXNzZWQgdGhhdCBhcmUgbm90ICRhdG9taWMgb3BlcmF0aW9ucyB3aWxsIGJlY29tZSAkc2V0IG9wcy5fXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBVcGRhdGUgdGhlIGZpcnN0IGRvY3VtZW50IHdob3NlIGB0aXRsZWAgY29udGFpbnMgJ3Rlc3QnXG4gKiAgICAgbXF1ZXJ5KCkudXBkYXRlTWFueSh7IHRpdGxlOiAvdGVzdC8gfSwgeyB5ZWFyOiAyMDE3IH0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtjcml0ZXJpYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbZG9jXSB0aGUgdXBkYXRlIGNvbW1hbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS51cGRhdGVPbmUgPSBmdW5jdGlvbiB1cGRhdGVPbmUoY3JpdGVyaWEsIGRvYywgb3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGRvYyA9IGNyaXRlcmlhO1xuICAgIGNyaXRlcmlhID0gb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBfdXBkYXRlKHRoaXMsICd1cGRhdGVPbmUnLCBjcml0ZXJpYSwgZG9jLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBgdXBkYXRlT25lYCBRdWVyeVxuICogQHJldHVybnMgdGhlIHJlc3VsdHNcbiAqL1xuUXVlcnkucHJvdG90eXBlLl91cGRhdGVPbmUgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIF91cGRhdGVFeGVjKHRoaXMsICd1cGRhdGVPbmUnKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZSBhbmQvb3IgZXhlY3V0ZSB0aGlzIHF1ZXJ5IGFzIGFuIGByZXBsYWNlT25lKClgIG9wZXJhdGlvbi4gU2ltaWxhclxuICogdG8gYHVwZGF0ZU9uZSgpYCwgZXhjZXB0IGByZXBsYWNlT25lKClgIGlzIG5vdCBhbGxvd2VkIHRvIHVzZSBhdG9taWNcbiAqIG1vZGlmaWVycyAoYCRzZXRgLCBgJHB1c2hgLCBldGMuKS4gQ2FsbGluZyBgcmVwbGFjZU9uZSgpYCB3aWxsIGFsd2F5c1xuICogcmVwbGFjZSB0aGUgZXhpc3RpbmcgZG9jLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gUmVwbGFjZSB0aGUgZG9jdW1lbnQgd2l0aCBgX2lkYCAxIHdpdGggYHsgX2lkOiAxLCB5ZWFyOiAyMDE3IH1gXG4gKiAgICAgbXF1ZXJ5KCkucmVwbGFjZU9uZSh7IF9pZDogMSB9LCB7IHllYXI6IDIwMTcgfSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2NyaXRlcmlhXVxuICogQHBhcmFtIHtPYmplY3R9IFtkb2NdIHRoZSB1cGRhdGUgY29tbWFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnJlcGxhY2VPbmUgPSBmdW5jdGlvbiByZXBsYWNlT25lKGNyaXRlcmlhLCBkb2MsIG9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBkb2MgPSBjcml0ZXJpYTtcbiAgICBjcml0ZXJpYSA9IG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB0aGlzLnNldE9wdGlvbnMoeyBvdmVyd3JpdGU6IHRydWUgfSk7XG4gIHJldHVybiBfdXBkYXRlKHRoaXMsICdyZXBsYWNlT25lJywgY3JpdGVyaWEsIGRvYywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgYHJlcGxhY2VPbmVgIFF1ZXJ5XG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0c1xuICovXG5RdWVyeS5wcm90b3R5cGUuX3JlcGxhY2VPbmUgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIF91cGRhdGVFeGVjKHRoaXMsICdyZXBsYWNlT25lJyk7XG59O1xuXG4vKiFcbiAqIEludGVybmFsIGhlbHBlciBmb3IgdXBkYXRlTWFueSwgdXBkYXRlT25lXG4gKi9cblxuZnVuY3Rpb24gX3VwZGF0ZShxdWVyeSwgb3AsIGNyaXRlcmlhLCBkb2MsIG9wdGlvbnMpIHtcbiAgcXVlcnkub3AgPSBvcDtcblxuICBpZiAoUXVlcnkuY2FuTWVyZ2UoY3JpdGVyaWEpKSB7XG4gICAgcXVlcnkubWVyZ2UoY3JpdGVyaWEpO1xuICB9XG5cbiAgaWYgKGRvYykge1xuICAgIHF1ZXJ5Ll9tZXJnZVVwZGF0ZShkb2MpO1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgLy8geyBvdmVyd3JpdGU6IHRydWUgfVxuICAgIHF1ZXJ5LnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gcXVlcnk7XG59XG5cbi8qKlxuICogSGVscGVyIGZvciBkZS1kdXBsaWNhdGluZyBcInVwZGF0ZSpcIiBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7UXVlcnl9IHF1ZXJ5IFRoZSBRdWVyeSBPYmplY3QgKHJlcGxhY2VtZW50IGZvciBcInRoaXNcIilcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcCBUaGUgT3BlcmF0aW9uIHRvIGJlIGRvbmVcbiAqIEByZXR1cm5zIHRoZSByZXN1bHRzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF91cGRhdGVFeGVjKHF1ZXJ5LCBvcCkge1xuICBjb25zdCBvcHRpb25zID0gcXVlcnkuX29wdGlvbnNGb3JFeGVjKCk7XG5cbiAgY29uc3QgY3JpdGVyaWEgPSBxdWVyeS5fY29uZGl0aW9ucztcbiAgY29uc3QgZG9jID0gcXVlcnkuX3VwZGF0ZUZvckV4ZWMoKTtcblxuICBkZWJ1ZygndXBkYXRlJywgcXVlcnkuX2NvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWUsIGNyaXRlcmlhLCBkb2MsIG9wdGlvbnMpO1xuXG4gIHJldHVybiBxdWVyeS5fY29sbGVjdGlvbltvcF0oY3JpdGVyaWEsIGRvYywgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogRGVjbGFyZSBhbmQvb3IgZXhlY3V0ZSB0aGlzIHF1ZXJ5IGFzIGEgYGRlbGV0ZU9uZSgpYCBvcGVyYXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBtcXVlcnkoY29sbGVjdGlvbikuZGVsZXRlT25lKHsgYXJ0aXN0OiAnQW5uZSBNdXJyYXknIH0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R8UXVlcnl9IFtjcml0ZXJpYV0gbW9uZ29kYiBzZWxlY3RvclxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmRlbGV0ZU9uZSA9IGZ1bmN0aW9uKGNyaXRlcmlhKSB7XG4gIHRoaXMub3AgPSAnZGVsZXRlT25lJztcblxuICBpZiAoUXVlcnkuY2FuTWVyZ2UoY3JpdGVyaWEpKSB7XG4gICAgdGhpcy5tZXJnZShjcml0ZXJpYSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBgZGVsZXRlT25lYCBRdWVyeVxuICogQHJldHVybnMgdGhlIHJlc3VsdHNcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9kZWxldGVPbmUgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG4gIGRlbGV0ZSBvcHRpb25zLmp1c3RPbmU7XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zO1xuXG4gIGRlYnVnKCdkZWxldGVPbmUnLCB0aGlzLl9jb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lLCBjb25kcywgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24uZGVsZXRlT25lKGNvbmRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZSBhbmQvb3IgZXhlY3V0ZSB0aGlzIHF1ZXJ5IGFzIGEgYGRlbGV0ZU1hbnkoKWAgb3BlcmF0aW9uLiBBbHdheXMgZGVsZXRlc1xuICogX2V2ZXJ5XyBkb2N1bWVudCB0aGF0IG1hdGNoZXMgYGNyaXRlcmlhYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGF3YWl0IG1xdWVyeShjb2xsZWN0aW9uKS5kZWxldGVNYW55KHsgYXJ0aXN0OiAnQW5uZSBNdXJyYXknIH0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R8UXVlcnl9IFtjcml0ZXJpYV0gbW9uZ29kYiBzZWxlY3RvclxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmRlbGV0ZU1hbnkgPSBmdW5jdGlvbihjcml0ZXJpYSkge1xuICB0aGlzLm9wID0gJ2RlbGV0ZU1hbnknO1xuXG4gIGlmIChRdWVyeS5jYW5NZXJnZShjcml0ZXJpYSkpIHtcbiAgICB0aGlzLm1lcmdlKGNyaXRlcmlhKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGBkZWxldGVNYW55YCBRdWVyeVxuICogQHJldHVybnMgdGhlIHJlc3VsdHNcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9kZWxldGVNYW55ID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuICBkZWxldGUgb3B0aW9ucy5qdXN0T25lO1xuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9ucztcblxuICBkZWJ1ZygnZGVsZXRlT25lJywgdGhpcy5fY29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZSwgY29uZHMsIG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uLmRlbGV0ZU1hbnkoY29uZHMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBJc3N1ZXMgYSBtb25nb2RiIFtmaW5kQW5kTW9kaWZ5XShodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9maW5kQW5kTW9kaWZ5K0NvbW1hbmQpIHVwZGF0ZSBjb21tYW5kLlxuICpcbiAqIEZpbmRzIGEgbWF0Y2hpbmcgZG9jdW1lbnQsIHVwZGF0ZXMgaXQgYWNjb3JkaW5nIHRvIHRoZSBgdXBkYXRlYCBhcmcsIHBhc3NpbmcgYW55IGBvcHRpb25zYCwgYW5kIHJldHVybnMgdGhlIGZvdW5kIGRvY3VtZW50IChpZiBhbnkpLlxuICpcbiAqICMjIyMgQXZhaWxhYmxlIG9wdGlvbnNcbiAqXG4gKiAtIGBuZXdgOiBib29sIC0gdHJ1ZSB0byByZXR1cm4gdGhlIG1vZGlmaWVkIGRvY3VtZW50IHJhdGhlciB0aGFuIHRoZSBvcmlnaW5hbC4gZGVmYXVsdHMgdG8gdHJ1ZVxuICogLSBgdXBzZXJ0YDogYm9vbCAtIGNyZWF0ZXMgdGhlIG9iamVjdCBpZiBpdCBkb2Vzbid0IGV4aXN0LiBkZWZhdWx0cyB0byBmYWxzZS5cbiAqIC0gYHNvcnRgOiBpZiBtdWx0aXBsZSBkb2NzIGFyZSBmb3VuZCBieSB0aGUgY29uZGl0aW9ucywgc2V0cyB0aGUgc29ydCBvcmRlciB0byBjaG9vc2Ugd2hpY2ggZG9jIHRvIHVwZGF0ZVxuICpcbiAqICMjIyMgRXhhbXBsZXM6XG4gKlxuICogICAgIGF3YWl0IHF1ZXJ5LmZpbmRPbmVBbmRVcGRhdGUoY29uZGl0aW9ucywgdXBkYXRlLCBvcHRpb25zKSAvLyBleGVjdXRlc1xuICogICAgIHF1ZXJ5LmZpbmRPbmVBbmRVcGRhdGUoY29uZGl0aW9ucywgdXBkYXRlLCBvcHRpb25zKSAgLy8gcmV0dXJucyBRdWVyeVxuICogICAgIGF3YWl0IHF1ZXJ5LmZpbmRPbmVBbmRVcGRhdGUoY29uZGl0aW9ucywgdXBkYXRlKSAvLyBleGVjdXRlc1xuICogICAgIHF1ZXJ5LmZpbmRPbmVBbmRVcGRhdGUoY29uZGl0aW9ucywgdXBkYXRlKSAgICAgICAgICAgLy8gcmV0dXJucyBRdWVyeVxuICogICAgIGF3YWl0IHF1ZXJ5LmZpbmRPbmVBbmRVcGRhdGUodXBkYXRlKSAgICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgcXVlcnkuZmluZE9uZUFuZFVwZGF0ZSh1cGRhdGUpICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgYXdhaXQgcXVlcnkuZmluZE9uZUFuZFVwZGF0ZSgpICAgICAgICAgICAgICAgICAgICAgLy8gZXhlY3V0ZXNcbiAqICAgICBxdWVyeS5maW5kT25lQW5kVXBkYXRlKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgUXVlcnlcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxRdWVyeX0gW3F1ZXJ5XVxuICogQHBhcmFtIHtPYmplY3R9IFtkb2NdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvZmluZEFuZE1vZGlmeStDb21tYW5kXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZmluZE9uZUFuZFVwZGF0ZSA9IGZ1bmN0aW9uKGNyaXRlcmlhLCBkb2MsIG9wdGlvbnMpIHtcbiAgdGhpcy5vcCA9ICdmaW5kT25lQW5kVXBkYXRlJztcbiAgdGhpcy5fdmFsaWRhdGUoKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGRvYyA9IGNyaXRlcmlhO1xuICAgIGNyaXRlcmlhID0gb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmIChRdWVyeS5jYW5NZXJnZShjcml0ZXJpYSkpIHtcbiAgICB0aGlzLm1lcmdlKGNyaXRlcmlhKTtcbiAgfVxuXG4gIC8vIGFwcGx5IGRvY1xuICBpZiAoZG9jKSB7XG4gICAgdGhpcy5fbWVyZ2VVcGRhdGUoZG9jKTtcbiAgfVxuXG4gIG9wdGlvbnMgJiYgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGBmaW5kT25lQW5kVXBkYXRlYCBRdWVyeVxuICogQHJldHVybnMgdGhlIHJlc3VsdHNcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9maW5kT25lQW5kVXBkYXRlID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9ucztcbiAgY29uc3QgdXBkYXRlID0gdGhpcy5fdXBkYXRlRm9yRXhlYygpO1xuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcblxuICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi5maW5kT25lQW5kVXBkYXRlKGNvbmRzLCB1cGRhdGUsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBJc3N1ZXMgYSBtb25nb2RiIFtmaW5kQW5kTW9kaWZ5XShodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9maW5kQW5kTW9kaWZ5K0NvbW1hbmQpIHJlbW92ZSBjb21tYW5kLlxuICpcbiAqIEZpbmRzIGEgbWF0Y2hpbmcgZG9jdW1lbnQsIHJlbW92ZXMgaXQsIHJldHVybmluZyB0aGUgZm91bmQgZG9jdW1lbnQgKGlmIGFueSkuXG4gKlxuICogIyMjIyBBdmFpbGFibGUgb3B0aW9uc1xuICpcbiAqIC0gYHNvcnRgOiBpZiBtdWx0aXBsZSBkb2NzIGFyZSBmb3VuZCBieSB0aGUgY29uZGl0aW9ucywgc2V0cyB0aGUgc29ydCBvcmRlciB0byBjaG9vc2Ugd2hpY2ggZG9jIHRvIHVwZGF0ZVxuICpcbiAqICMjIyMgRXhhbXBsZXM6XG4gKlxuICogICAgIGF3YWl0IEEud2hlcmUoKS5maW5kT25lQW5kUmVtb3ZlKGNvbmRpdGlvbnMsIG9wdGlvbnMpIC8vIGV4ZWN1dGVzXG4gKiAgICAgQS53aGVyZSgpLmZpbmRPbmVBbmRSZW1vdmUoY29uZGl0aW9ucywgb3B0aW9ucykgIC8vIHJldHVybiBRdWVyeVxuICogICAgIGF3YWl0IEEud2hlcmUoKS5maW5kT25lQW5kUmVtb3ZlKGNvbmRpdGlvbnMpIC8vIGV4ZWN1dGVzXG4gKiAgICAgQS53aGVyZSgpLmZpbmRPbmVBbmRSZW1vdmUoY29uZGl0aW9ucykgLy8gcmV0dXJucyBRdWVyeVxuICogICAgIGF3YWl0IEEud2hlcmUoKS5maW5kT25lQW5kUmVtb3ZlKCkgICAvLyBleGVjdXRlc1xuICogICAgIEEud2hlcmUoKS5maW5kT25lQW5kUmVtb3ZlKCkgICAgICAgICAgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBBLndoZXJlKCkuZmluZE9uZUFuZERlbGV0ZSgpICAgICAgICAgICAvLyBhbGlhcyBvZiAuZmluZE9uZUFuZFJlbW92ZSgpXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtjb25kaXRpb25zXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9maW5kQW5kTW9kaWZ5K0NvbW1hbmRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmZpbmRPbmVBbmRSZW1vdmUgPSBRdWVyeS5wcm90b3R5cGUuZmluZE9uZUFuZERlbGV0ZSA9IGZ1bmN0aW9uKGNvbmRpdGlvbnMsIG9wdGlvbnMpIHtcbiAgdGhpcy5vcCA9ICdmaW5kT25lQW5kUmVtb3ZlJztcbiAgdGhpcy5fdmFsaWRhdGUoKTtcblxuICAvLyBhcHBseSBjb25kaXRpb25zXG4gIGlmIChRdWVyeS5jYW5NZXJnZShjb25kaXRpb25zKSkge1xuICAgIHRoaXMubWVyZ2UoY29uZGl0aW9ucyk7XG4gIH1cblxuICAvLyBhcHBseSBvcHRpb25zXG4gIG9wdGlvbnMgJiYgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGBmaW5kT25lQW5kUmVtb3ZlYCBRdWVyeVxuICogQHJldHVybnMgdGhlIHJlc3VsdHNcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9maW5kT25lQW5kUmVtb3ZlID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnM7XG5cbiAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24uZmluZE9uZUFuZERlbGV0ZShjb25kcywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEFkZCB0cmFjZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIHdoZW4gdGhlIHF1ZXJ5IGlzIGV4ZWN1dGVkLlxuICogVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGggKG1ldGhvZCwgcXVlcnlJbmZvLCBxdWVyeSkgYW5kXG4gKiBzaG91bGQgcmV0dXJuIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWRcbiAqIHdpdGggKGVyciwgcmVzdWx0LCBtaWxsaXMpIHdoZW4gdGhlIHF1ZXJ5IGlzIGNvbXBsZXRlLlxuICpcbiAqIHF1ZXJ5SW5mbyBpcyBhbiBvYmplY3QgY29udGFpbmluZzoge1xuICogICBjb2xsZWN0aW9uTmFtZTogPG5hbWUgb2YgdGhlIGNvbGxlY3Rpb24+LFxuICogICBjb25kaXRpb25zOiA8cXVlcnkgY3JpdGVyaWE+LFxuICogICBvcHRpb25zOiA8Y29tbWVudCwgZmllbGRzLCByZWFkUHJlZmVyZW5jZSwgZXRjPixcbiAqICAgZG9jOiBbZG9jdW1lbnQgdG8gdXBkYXRlLCBpZiBhcHBsaWNhYmxlXVxuICogfVxuICpcbiAqIE5PVEU6IERvZXMgbm90IHRyYWNlIHN0cmVhbSBxdWVyaWVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYWNlRnVuY3Rpb25cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5RdWVyeS5wcm90b3R5cGUuc2V0VHJhY2VGdW5jdGlvbiA9IGZ1bmN0aW9uKHRyYWNlRnVuY3Rpb24pIHtcbiAgdGhpcy5fdHJhY2VGdW5jdGlvbiA9IHRyYWNlRnVuY3Rpb247XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgcXVlcnlcbiAqXG4gKiAjIyMjIEV4YW1wbGVzOlxuICpcbiAqICAgICBxdWVyeS5leGVjKCk7XG4gKiAgICAgYXdhaXQgcXVlcnkuZXhlYygpO1xuICogICAgIHF1ZXJ5LmV4ZWMoJ3VwZGF0ZScpO1xuICogICAgIGF3YWl0IHF1ZXJ5LmV4ZWMoJ2ZpbmQnKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gW29wZXJhdGlvbl1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmV4ZWMgPSBhc3luYyBmdW5jdGlvbiBleGVjKG9wKSB7XG4gIGlmICh0eXBlb2Ygb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5vcCA9IG9wO1xuICB9XG5cbiAgYXNzZXJ0Lm9rKHRoaXMub3AsICdNaXNzaW5nIHF1ZXJ5IHR5cGU6IChmaW5kLCBldGMpJyk7XG5cbiAgY29uc3QgZm5OYW1lID0gJ18nICsgdGhpcy5vcDtcblxuICAvLyBiZXR0ZXIgZXJyb3IsIGJlY2F1c2UgZGVmYXVsdCB3b3VsZCBsaXN0IGl0IGFzIFwidGhpc1tmbk5hbWVdIGlzIG5vdCBhIGZ1bmN0aW9uXCJcbiAgaWYgKHR5cGVvZiB0aGlzW2ZuTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0aGlzWyR7Zm5OYW1lfV0gaXMgbm90IGEgZnVuY3Rpb25gKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzW2ZuTmFtZV0oKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHF1ZXJ5IHJldHVybmluZyBhIGBQcm9taXNlYCB3aGljaCB3aWxsIGJlXG4gKiByZXNvbHZlZCB3aXRoIGVpdGhlciB0aGUgZG9jKHMpIG9yIHJlamVjdGVkIHdpdGggdGhlIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3JlamVjdF1cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS50aGVuID0gYXN5bmMgZnVuY3Rpb24ocmVzLCByZWopIHtcbiAgcmV0dXJuIHRoaXMuZXhlYygpLnRoZW4ocmVzLCByZWopO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgY3Vyc29yIGZvciB0aGUgZ2l2ZW4gYGZpbmRgIHF1ZXJ5LlxuICpcbiAqIEB0aHJvd3MgRXJyb3IgaWYgb3BlcmF0aW9uIGlzIG5vdCBhIGZpbmRcbiAqIEByZXR1cm5zIHtDdXJzb3J9IE1vbmdvREIgZHJpdmVyIGN1cnNvclxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5jdXJzb3IgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCdmaW5kJyAhPSB0aGlzLm9wKVxuICAgIHRocm93IG5ldyBFcnJvcignY3Vyc29yKCkgaXMgb25seSBhdmFpbGFibGUgZm9yIGZpbmQnKTtcblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnM7XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG4gIGlmICh0aGlzLiR1c2VQcm9qZWN0aW9uKSB7XG4gICAgb3B0aW9ucy5wcm9qZWN0aW9uID0gdGhpcy5fZmllbGRzRm9yRXhlYygpO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMuZmllbGRzID0gdGhpcy5fZmllbGRzRm9yRXhlYygpO1xuICB9XG5cbiAgZGVidWcoJ2N1cnNvcicsIHRoaXMuX2NvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWUsIGNvbmRzLCBvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi5maW5kQ3Vyc29yKGNvbmRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBmaWVsZCBzZWxlY3Rpb24gaGFzIGJlZW4gbWFkZS5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2VsZWN0ZWQgPSBmdW5jdGlvbiBzZWxlY3RlZCgpIHtcbiAgcmV0dXJuICEhKHRoaXMuX2ZpZWxkcyAmJiBPYmplY3Qua2V5cyh0aGlzLl9maWVsZHMpLmxlbmd0aCA+IDApO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGluY2x1c2l2ZSBmaWVsZCBzZWxlY3Rpb24gaGFzIGJlZW4gbWFkZS5cbiAqXG4gKiAgICAgcXVlcnkuc2VsZWN0ZWRJbmNsdXNpdmVseSgpIC8vIGZhbHNlXG4gKiAgICAgcXVlcnkuc2VsZWN0KCduYW1lJylcbiAqICAgICBxdWVyeS5zZWxlY3RlZEluY2x1c2l2ZWx5KCkgLy8gdHJ1ZVxuICogICAgIHF1ZXJ5LnNlbGVjdGVkRXhsdXNpdmVseSgpIC8vIGZhbHNlXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNlbGVjdGVkSW5jbHVzaXZlbHkgPSBmdW5jdGlvbiBzZWxlY3RlZEluY2x1c2l2ZWx5KCkge1xuICBpZiAoIXRoaXMuX2ZpZWxkcykgcmV0dXJuIGZhbHNlO1xuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9maWVsZHMpO1xuICBpZiAoMCA9PT0ga2V5cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGlmICgwID09PSB0aGlzLl9maWVsZHNba2V5XSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aGlzLl9maWVsZHNba2V5XSAmJlxuICAgICAgICB0eXBlb2YgdGhpcy5fZmllbGRzW2tleV0gPT09ICdvYmplY3QnICYmXG4gICAgICAgIHRoaXMuX2ZpZWxkc1trZXldLiRtZXRhKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgZXhjbHVzaXZlIGZpZWxkIHNlbGVjdGlvbiBoYXMgYmVlbiBtYWRlLlxuICpcbiAqICAgICBxdWVyeS5zZWxlY3RlZEV4bHVzaXZlbHkoKSAvLyBmYWxzZVxuICogICAgIHF1ZXJ5LnNlbGVjdCgnLW5hbWUnKVxuICogICAgIHF1ZXJ5LnNlbGVjdGVkRXhsdXNpdmVseSgpIC8vIHRydWVcbiAqICAgICBxdWVyeS5zZWxlY3RlZEluY2x1c2l2ZWx5KCkgLy8gZmFsc2VcbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2VsZWN0ZWRFeGNsdXNpdmVseSA9IGZ1bmN0aW9uIHNlbGVjdGVkRXhjbHVzaXZlbHkoKSB7XG4gIGlmICghdGhpcy5fZmllbGRzKSByZXR1cm4gZmFsc2U7XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX2ZpZWxkcyk7XG4gIGlmICgwID09PSBrZXlzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgaWYgKDAgPT09IHRoaXMuX2ZpZWxkc1trZXldKSByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogTWVyZ2VzIGBkb2NgIHdpdGggdGhlIGN1cnJlbnQgdXBkYXRlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9tZXJnZVVwZGF0ZSA9IGZ1bmN0aW9uKGRvYykge1xuICBpZiAoIXRoaXMuX3VwZGF0ZURvYykgdGhpcy5fdXBkYXRlRG9jID0ge307XG4gIGlmIChkb2MgaW5zdGFuY2VvZiBRdWVyeSkge1xuICAgIGlmIChkb2MuX3VwZGF0ZURvYykge1xuICAgICAgdXRpbHMubWVyZ2VDbG9uZSh0aGlzLl91cGRhdGVEb2MsIGRvYy5fdXBkYXRlRG9jKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdXRpbHMubWVyZ2VDbG9uZSh0aGlzLl91cGRhdGVEb2MsIGRvYyk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBkZWZhdWx0IG9wdGlvbnMuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9vcHRpb25zRm9yRXhlYyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBvcHRpb25zID0gdXRpbHMuY2xvbmUodGhpcy5vcHRpb25zKTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZmllbGRzIHNlbGVjdGlvbiBmb3IgdGhpcyBxdWVyeS5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX2ZpZWxkc0ZvckV4ZWMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHV0aWxzLmNsb25lKHRoaXMuX2ZpZWxkcyk7XG59O1xuXG4vKipcbiAqIFJldHVybiBhbiB1cGRhdGUgZG9jdW1lbnQgd2l0aCBjb3JyZWN0ZWQgJHNldCBvcGVyYXRpb25zLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fdXBkYXRlRm9yRXhlYyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCB1cGRhdGUgPSB1dGlscy5jbG9uZSh0aGlzLl91cGRhdGVEb2MpO1xuICBjb25zdCBvcHMgPSB1dGlscy5rZXlzKHVwZGF0ZSk7XG4gIGNvbnN0IHJldCA9IHt9O1xuXG4gIGZvciAoY29uc3Qgb3Agb2Ygb3BzKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vdmVyd3JpdGUpIHtcbiAgICAgIHJldFtvcF0gPSB1cGRhdGVbb3BdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCckJyAhPT0gb3BbMF0pIHtcbiAgICAgIC8vIGZpeCB1cCAkc2V0IHN1Z2FyXG4gICAgICBpZiAoIXJldC4kc2V0KSB7XG4gICAgICAgIGlmICh1cGRhdGUuJHNldCkge1xuICAgICAgICAgIHJldC4kc2V0ID0gdXBkYXRlLiRzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0LiRzZXQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0LiRzZXRbb3BdID0gdXBkYXRlW29wXTtcbiAgICAgIGlmICghfm9wcy5pbmRleE9mKCckc2V0JykpIG9wcy5wdXNoKCckc2V0Jyk7XG4gICAgfSBlbHNlIGlmICgnJHNldCcgPT09IG9wKSB7XG4gICAgICBpZiAoIXJldC4kc2V0KSB7XG4gICAgICAgIHJldFtvcF0gPSB1cGRhdGVbb3BdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXRbb3BdID0gdXBkYXRlW29wXTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9jb21waWxlZFVwZGF0ZSA9IHJldDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogTWFrZSBzdXJlIF9wYXRoIGlzIHNldC5cbiAqXG4gKiBAcGFybWFtIHtTdHJpbmd9IG1ldGhvZFxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fZW5zdXJlUGF0aCA9IGZ1bmN0aW9uKG1ldGhvZCkge1xuICBpZiAoIXRoaXMuX3BhdGgpIHtcbiAgICBjb25zdCBtc2cgPSBtZXRob2QgKyAnKCkgbXVzdCBiZSB1c2VkIGFmdGVyIHdoZXJlKCkgJ1xuICAgICAgICAgICAgICAgICAgICAgKyAnd2hlbiBjYWxsZWQgd2l0aCB0aGVzZSBhcmd1bWVudHMnO1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICB9XG59O1xuXG4vKiFcbiAqIFBlcm1pc3Npb25zXG4gKi9cblxuUXVlcnkucGVybWlzc2lvbnMgPSByZXF1aXJlKCcuL3Blcm1pc3Npb25zJyk7XG5cblF1ZXJ5Ll9pc1Blcm1pdHRlZCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgY29uc3QgZGVuaWVkID0gUXVlcnkucGVybWlzc2lvbnNbYl07XG4gIGlmICghZGVuaWVkKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIHRydWUgIT09IGRlbmllZFthXTtcbn07XG5cblF1ZXJ5LnByb3RvdHlwZS5fdmFsaWRhdGUgPSBmdW5jdGlvbihhY3Rpb24pIHtcbiAgbGV0IGZhaWw7XG4gIGxldCB2YWxpZGF0b3I7XG5cbiAgaWYgKHVuZGVmaW5lZCA9PT0gYWN0aW9uKSB7XG5cbiAgICB2YWxpZGF0b3IgPSBRdWVyeS5wZXJtaXNzaW9uc1t0aGlzLm9wXTtcbiAgICBpZiAoJ2Z1bmN0aW9uJyAhPSB0eXBlb2YgdmFsaWRhdG9yKSByZXR1cm4gdHJ1ZTtcblxuICAgIGZhaWwgPSB2YWxpZGF0b3IodGhpcyk7XG5cbiAgfSBlbHNlIGlmICghUXVlcnkuX2lzUGVybWl0dGVkKGFjdGlvbiwgdGhpcy5vcCkpIHtcbiAgICBmYWlsID0gYWN0aW9uO1xuICB9XG5cbiAgaWYgKGZhaWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZmFpbCArICcgY2Fubm90IGJlIHVzZWQgd2l0aCAnICsgdGhpcy5vcCk7XG4gIH1cbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBgY29uZHNgIGNhbiBiZSBtZXJnZWQgdXNpbmcgYG1xdWVyeSgpLm1lcmdlKClgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmRzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cblF1ZXJ5LmNhbk1lcmdlID0gZnVuY3Rpb24oY29uZHMpIHtcbiAgcmV0dXJuIGNvbmRzIGluc3RhbmNlb2YgUXVlcnkgfHwgdXRpbHMuaXNPYmplY3QoY29uZHMpO1xufTtcblxuLyoqXG4gKiBTZXQgYSB0cmFjZSBmdW5jdGlvbiB0aGF0IHdpbGwgZ2V0IGNhbGxlZCB3aGVuZXZlciBhXG4gKiBxdWVyeSBpcyBleGVjdXRlZC5cbiAqXG4gKiBTZWUgYHNldFRyYWNlRnVuY3Rpb24oKWAgZm9yIGRldGFpbHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmRzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5RdWVyeS5zZXRHbG9iYWxUcmFjZUZ1bmN0aW9uID0gZnVuY3Rpb24odHJhY2VGdW5jdGlvbikge1xuICBRdWVyeS50cmFjZUZ1bmN0aW9uID0gdHJhY2VGdW5jdGlvbjtcbn07XG5cbi8qIVxuICogRXhwb3J0cy5cbiAqL1xuXG5RdWVyeS51dGlscyA9IHV0aWxzO1xuUXVlcnkuZW52ID0gcmVxdWlyZSgnLi9lbnYnKTtcblF1ZXJ5LkNvbGxlY3Rpb24gPSByZXF1aXJlKCcuL2NvbGxlY3Rpb24nKTtcblF1ZXJ5LkJhc2VDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi9jb2xsZWN0aW9uL2NvbGxlY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFF1ZXJ5O1xuXG4vLyBUT0RPXG4vLyB0ZXN0IHV0aWxzXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/mquery.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/permissions.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/permissions.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nconst denied = exports;\n\ndenied.distinct = function(self) {\n  if (self._fields && Object.keys(self._fields).length > 0) {\n    return 'field selection and slice';\n  }\n\n  const keys = Object.keys(denied.distinct);\n  let err;\n\n  keys.every(function(option) {\n    if (self.options[option]) {\n      err = option;\n      return false;\n    }\n    return true;\n  });\n\n  return err;\n};\ndenied.distinct.select =\ndenied.distinct.slice =\ndenied.distinct.sort =\ndenied.distinct.limit =\ndenied.distinct.skip =\ndenied.distinct.batchSize =\ndenied.distinct.hint =\ndenied.distinct.tailable = true;\n\n\n// aggregation integration\n\n\ndenied.findOneAndUpdate =\ndenied.findOneAndRemove = function(self) {\n  const keys = Object.keys(denied.findOneAndUpdate);\n  let err;\n\n  keys.every(function(option) {\n    if (self.options[option]) {\n      err = option;\n      return false;\n    }\n    return true;\n  });\n\n  return err;\n};\ndenied.findOneAndUpdate.limit =\ndenied.findOneAndUpdate.skip =\ndenied.findOneAndUpdate.batchSize =\ndenied.findOneAndUpdate.tailable = true;\n\n\ndenied.count = function(self) {\n  if (self._fields && Object.keys(self._fields).length > 0) {\n    return 'field selection and slice';\n  }\n\n  const keys = Object.keys(denied.count);\n  let err;\n\n  keys.every(function(option) {\n    if (self.options[option]) {\n      err = option;\n      return false;\n    }\n    return true;\n  });\n\n  return err;\n};\n\ndenied.count.slice =\ndenied.count.batchSize =\ndenied.count.tailable = true;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21xdWVyeUA1LjAuMC9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9wZXJtaXNzaW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGVyaWNfXFxEZXNrdG9wXFxzeW5lcmd5LW1hdGNoLWFwcFxcbm9kZV9tb2R1bGVzXFwucG5wbVxcbXF1ZXJ5QDUuMC4wXFxub2RlX21vZHVsZXNcXG1xdWVyeVxcbGliXFxwZXJtaXNzaW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGRlbmllZCA9IGV4cG9ydHM7XG5cbmRlbmllZC5kaXN0aW5jdCA9IGZ1bmN0aW9uKHNlbGYpIHtcbiAgaWYgKHNlbGYuX2ZpZWxkcyAmJiBPYmplY3Qua2V5cyhzZWxmLl9maWVsZHMpLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gJ2ZpZWxkIHNlbGVjdGlvbiBhbmQgc2xpY2UnO1xuICB9XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRlbmllZC5kaXN0aW5jdCk7XG4gIGxldCBlcnI7XG5cbiAga2V5cy5ldmVyeShmdW5jdGlvbihvcHRpb24pIHtcbiAgICBpZiAoc2VsZi5vcHRpb25zW29wdGlvbl0pIHtcbiAgICAgIGVyciA9IG9wdGlvbjtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBlcnI7XG59O1xuZGVuaWVkLmRpc3RpbmN0LnNlbGVjdCA9XG5kZW5pZWQuZGlzdGluY3Quc2xpY2UgPVxuZGVuaWVkLmRpc3RpbmN0LnNvcnQgPVxuZGVuaWVkLmRpc3RpbmN0LmxpbWl0ID1cbmRlbmllZC5kaXN0aW5jdC5za2lwID1cbmRlbmllZC5kaXN0aW5jdC5iYXRjaFNpemUgPVxuZGVuaWVkLmRpc3RpbmN0LmhpbnQgPVxuZGVuaWVkLmRpc3RpbmN0LnRhaWxhYmxlID0gdHJ1ZTtcblxuXG4vLyBhZ2dyZWdhdGlvbiBpbnRlZ3JhdGlvblxuXG5cbmRlbmllZC5maW5kT25lQW5kVXBkYXRlID1cbmRlbmllZC5maW5kT25lQW5kUmVtb3ZlID0gZnVuY3Rpb24oc2VsZikge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGVuaWVkLmZpbmRPbmVBbmRVcGRhdGUpO1xuICBsZXQgZXJyO1xuXG4gIGtleXMuZXZlcnkoZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgaWYgKHNlbGYub3B0aW9uc1tvcHRpb25dKSB7XG4gICAgICBlcnIgPSBvcHRpb247XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gZXJyO1xufTtcbmRlbmllZC5maW5kT25lQW5kVXBkYXRlLmxpbWl0ID1cbmRlbmllZC5maW5kT25lQW5kVXBkYXRlLnNraXAgPVxuZGVuaWVkLmZpbmRPbmVBbmRVcGRhdGUuYmF0Y2hTaXplID1cbmRlbmllZC5maW5kT25lQW5kVXBkYXRlLnRhaWxhYmxlID0gdHJ1ZTtcblxuXG5kZW5pZWQuY291bnQgPSBmdW5jdGlvbihzZWxmKSB7XG4gIGlmIChzZWxmLl9maWVsZHMgJiYgT2JqZWN0LmtleXMoc2VsZi5fZmllbGRzKS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuICdmaWVsZCBzZWxlY3Rpb24gYW5kIHNsaWNlJztcbiAgfVxuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkZW5pZWQuY291bnQpO1xuICBsZXQgZXJyO1xuXG4gIGtleXMuZXZlcnkoZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgaWYgKHNlbGYub3B0aW9uc1tvcHRpb25dKSB7XG4gICAgICBlcnIgPSBvcHRpb247XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gZXJyO1xufTtcblxuZGVuaWVkLmNvdW50LnNsaWNlID1cbmRlbmllZC5jb3VudC5iYXRjaFNpemUgPVxuZGVuaWVkLmNvdW50LnRhaWxhYmxlID0gdHJ1ZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/permissions.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/utils.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/utils.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst specialProperties = ['__proto__', 'constructor', 'prototype'];\n\n/**\n * Clones objects\n *\n * @param {Object} obj the object to clone\n * @param {Object} options\n * @return {Object} the cloned object\n * @api private\n */\n\nconst clone = exports.clone = function clone(obj, options) {\n  if (obj === undefined || obj === null)\n    return obj;\n\n  if (Array.isArray(obj))\n    return exports.cloneArray(obj, options);\n\n  if (obj.constructor) {\n    if (/ObjectI[dD]$/.test(obj.constructor.name)) {\n      return 'function' == typeof obj.clone\n        ? obj.clone()\n        : new obj.constructor(obj.id);\n    }\n\n    if (obj.constructor.name === 'ReadPreference') {\n      return new obj.constructor(obj.mode, clone(obj.tags, options));\n    }\n\n    if ('Binary' == obj._bsontype && obj.buffer && obj.value) {\n      return 'function' == typeof obj.clone\n        ? obj.clone()\n        : new obj.constructor(obj.value(true), obj.sub_type);\n    }\n\n    if ('Date' === obj.constructor.name || 'Function' === obj.constructor.name)\n      return new obj.constructor(+obj);\n\n    if ('RegExp' === obj.constructor.name)\n      return new RegExp(obj);\n\n    if ('Buffer' === obj.constructor.name)\n      return Buffer.from(obj);\n  }\n\n  if (isObject(obj))\n    return exports.cloneObject(obj, options);\n\n  if (obj.valueOf)\n    return obj.valueOf();\n};\n\n/*!\n * ignore\n */\n\nexports.cloneObject = function cloneObject(obj, options) {\n  const minimize = options && options.minimize,\n      ret = {},\n      keys = Object.keys(obj),\n      len = keys.length;\n  let hasKeys = false,\n      val,\n      k = '',\n      i = 0;\n\n  for (i = 0; i < len; ++i) {\n    k = keys[i];\n    // Not technically prototype pollution because this wouldn't merge properties\n    // onto `Object.prototype`, but avoid properties like __proto__ as a precaution.\n    if (specialProperties.indexOf(k) !== -1) {\n      continue;\n    }\n\n    val = clone(obj[k], options);\n\n    if (!minimize || ('undefined' !== typeof val)) {\n      hasKeys || (hasKeys = true);\n      ret[k] = val;\n    }\n  }\n\n  return minimize\n    ? hasKeys && ret\n    : ret;\n};\n\nexports.cloneArray = function cloneArray(arr, options) {\n  const ret = [],\n      l = arr.length;\n  let i = 0;\n  for (; i < l; i++)\n    ret.push(clone(arr[i], options));\n  return ret;\n};\n\n/**\n * Merges `from` into `to` without overwriting existing properties.\n *\n * @param {Object} to\n * @param {Object} from\n * @api private\n */\n\nexports.merge = function merge(to, from) {\n  const keys = Object.keys(from);\n\n  for (const key of keys) {\n    if (specialProperties.indexOf(key) !== -1) {\n      continue;\n    }\n    if ('undefined' === typeof to[key]) {\n      to[key] = from[key];\n    } else {\n      if (exports.isObject(from[key])) {\n        merge(to[key], from[key]);\n      } else {\n        to[key] = from[key];\n      }\n    }\n  }\n};\n\n/**\n * Same as merge but clones the assigned values.\n *\n * @param {Object} to\n * @param {Object} from\n * @api private\n */\n\nexports.mergeClone = function mergeClone(to, from) {\n  const keys = Object.keys(from);\n\n  for (const key of keys) {\n    if (specialProperties.indexOf(key) !== -1) {\n      continue;\n    }\n    if ('undefined' === typeof to[key]) {\n      to[key] = clone(from[key]);\n    } else {\n      if (exports.isObject(from[key])) {\n        mergeClone(to[key], from[key]);\n      } else {\n        to[key] = clone(from[key]);\n      }\n    }\n  }\n};\n\n/**\n * Read pref helper (mongo 2.2 drivers support this)\n *\n * Allows using aliases instead of full preference names:\n *\n *     p   primary\n *     pp  primaryPreferred\n *     s   secondary\n *     sp  secondaryPreferred\n *     n   nearest\n *\n * @param {String} pref\n */\n\nexports.readPref = function readPref(pref) {\n  switch (pref) {\n    case 'p':\n      pref = 'primary';\n      break;\n    case 'pp':\n      pref = 'primaryPreferred';\n      break;\n    case 's':\n      pref = 'secondary';\n      break;\n    case 'sp':\n      pref = 'secondaryPreferred';\n      break;\n    case 'n':\n      pref = 'nearest';\n      break;\n  }\n\n  return pref;\n};\n\n\n/**\n * Read Concern helper (mongo 3.2 drivers support this)\n *\n * Allows using string to specify read concern level:\n *\n *     local          3.2+\n *     available      3.6+\n *     majority       3.2+\n *     linearizable   3.4+\n *     snapshot       4.0+\n *\n * @param {String|Object} concern\n */\n\nexports.readConcern = function readConcern(concern) {\n  if ('string' === typeof concern) {\n    switch (concern) {\n      case 'l':\n        concern = 'local';\n        break;\n      case 'a':\n        concern = 'available';\n        break;\n      case 'm':\n        concern = 'majority';\n        break;\n      case 'lz':\n        concern = 'linearizable';\n        break;\n      case 's':\n        concern = 'snapshot';\n        break;\n    }\n    concern = { level: concern };\n  }\n  return concern;\n};\n\n/**\n * Object.prototype.toString.call helper\n */\n\nconst _toString = Object.prototype.toString;\nexports.toString = function(arg) {\n  return _toString.call(arg);\n};\n\n/**\n * Determines if `arg` is an object.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @return {Boolean}\n */\n\nconst isObject = exports.isObject = function(arg) {\n  return '[object Object]' == exports.toString(arg);\n};\n\n/**\n * Object.keys helper\n */\n\nexports.keys = Object.keys;\n\n/**\n * Basic Object.create polyfill.\n * Only one argument is supported.\n *\n * Based on https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create\n */\n\nexports.create = 'function' == typeof Object.create\n  ? Object.create\n  : create;\n\nfunction create(proto) {\n  if (arguments.length > 1) {\n    throw new Error('Adding properties is not supported');\n  }\n\n  function F() { }\n  F.prototype = proto;\n  return new F;\n}\n\n/**\n * inheritance\n */\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.prototype = exports.create(superCtor.prototype);\n  ctor.prototype.constructor = ctor;\n};\n\n/**\n * Check if this object is an arguments object\n *\n * @param {Any} v\n * @return {Boolean}\n */\n\nexports.isArgumentsObject = function(v) {\n  return Object.prototype.toString.call(v) === '[object Arguments]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21xdWVyeUA1LjAuMC9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUEsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7O0FBRUEsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlDQUF5QztBQUNwRCxZQUFZO0FBQ1o7O0FBRUEsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGVyaWNfXFxEZXNrdG9wXFxzeW5lcmd5LW1hdGNoLWFwcFxcbm9kZV9tb2R1bGVzXFwucG5wbVxcbXF1ZXJ5QDUuMC4wXFxub2RlX21vZHVsZXNcXG1xdWVyeVxcbGliXFx1dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBzcGVjaWFsUHJvcGVydGllcyA9IFsnX19wcm90b19fJywgJ2NvbnN0cnVjdG9yJywgJ3Byb3RvdHlwZSddO1xuXG4vKipcbiAqIENsb25lcyBvYmplY3RzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiB0aGUgb2JqZWN0IHRvIGNsb25lXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSB0aGUgY2xvbmVkIG9iamVjdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuY29uc3QgY2xvbmUgPSBleHBvcnRzLmNsb25lID0gZnVuY3Rpb24gY2xvbmUob2JqLCBvcHRpb25zKSB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IG51bGwpXG4gICAgcmV0dXJuIG9iajtcblxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKVxuICAgIHJldHVybiBleHBvcnRzLmNsb25lQXJyYXkob2JqLCBvcHRpb25zKTtcblxuICBpZiAob2JqLmNvbnN0cnVjdG9yKSB7XG4gICAgaWYgKC9PYmplY3RJW2REXSQvLnRlc3Qob2JqLmNvbnN0cnVjdG9yLm5hbWUpKSB7XG4gICAgICByZXR1cm4gJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygb2JqLmNsb25lXG4gICAgICAgID8gb2JqLmNsb25lKClcbiAgICAgICAgOiBuZXcgb2JqLmNvbnN0cnVjdG9yKG9iai5pZCk7XG4gICAgfVxuXG4gICAgaWYgKG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSAnUmVhZFByZWZlcmVuY2UnKSB7XG4gICAgICByZXR1cm4gbmV3IG9iai5jb25zdHJ1Y3RvcihvYmoubW9kZSwgY2xvbmUob2JqLnRhZ3MsIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICBpZiAoJ0JpbmFyeScgPT0gb2JqLl9ic29udHlwZSAmJiBvYmouYnVmZmVyICYmIG9iai52YWx1ZSkge1xuICAgICAgcmV0dXJuICdmdW5jdGlvbicgPT0gdHlwZW9mIG9iai5jbG9uZVxuICAgICAgICA/IG9iai5jbG9uZSgpXG4gICAgICAgIDogbmV3IG9iai5jb25zdHJ1Y3RvcihvYmoudmFsdWUodHJ1ZSksIG9iai5zdWJfdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKCdEYXRlJyA9PT0gb2JqLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ0Z1bmN0aW9uJyA9PT0gb2JqLmNvbnN0cnVjdG9yLm5hbWUpXG4gICAgICByZXR1cm4gbmV3IG9iai5jb25zdHJ1Y3Rvcigrb2JqKTtcblxuICAgIGlmICgnUmVnRXhwJyA9PT0gb2JqLmNvbnN0cnVjdG9yLm5hbWUpXG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChvYmopO1xuXG4gICAgaWYgKCdCdWZmZXInID09PSBvYmouY29uc3RydWN0b3IubmFtZSlcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShvYmopO1xuICB9XG5cbiAgaWYgKGlzT2JqZWN0KG9iaikpXG4gICAgcmV0dXJuIGV4cG9ydHMuY2xvbmVPYmplY3Qob2JqLCBvcHRpb25zKTtcblxuICBpZiAob2JqLnZhbHVlT2YpXG4gICAgcmV0dXJuIG9iai52YWx1ZU9mKCk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmV4cG9ydHMuY2xvbmVPYmplY3QgPSBmdW5jdGlvbiBjbG9uZU9iamVjdChvYmosIG9wdGlvbnMpIHtcbiAgY29uc3QgbWluaW1pemUgPSBvcHRpb25zICYmIG9wdGlvbnMubWluaW1pemUsXG4gICAgICByZXQgPSB7fSxcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhvYmopLFxuICAgICAgbGVuID0ga2V5cy5sZW5ndGg7XG4gIGxldCBoYXNLZXlzID0gZmFsc2UsXG4gICAgICB2YWwsXG4gICAgICBrID0gJycsXG4gICAgICBpID0gMDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBrID0ga2V5c1tpXTtcbiAgICAvLyBOb3QgdGVjaG5pY2FsbHkgcHJvdG90eXBlIHBvbGx1dGlvbiBiZWNhdXNlIHRoaXMgd291bGRuJ3QgbWVyZ2UgcHJvcGVydGllc1xuICAgIC8vIG9udG8gYE9iamVjdC5wcm90b3R5cGVgLCBidXQgYXZvaWQgcHJvcGVydGllcyBsaWtlIF9fcHJvdG9fXyBhcyBhIHByZWNhdXRpb24uXG4gICAgaWYgKHNwZWNpYWxQcm9wZXJ0aWVzLmluZGV4T2YoaykgIT09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YWwgPSBjbG9uZShvYmpba10sIG9wdGlvbnMpO1xuXG4gICAgaWYgKCFtaW5pbWl6ZSB8fCAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiB2YWwpKSB7XG4gICAgICBoYXNLZXlzIHx8IChoYXNLZXlzID0gdHJ1ZSk7XG4gICAgICByZXRba10gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1pbmltaXplXG4gICAgPyBoYXNLZXlzICYmIHJldFxuICAgIDogcmV0O1xufTtcblxuZXhwb3J0cy5jbG9uZUFycmF5ID0gZnVuY3Rpb24gY2xvbmVBcnJheShhcnIsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmV0ID0gW10sXG4gICAgICBsID0gYXJyLmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKDsgaSA8IGw7IGkrKylcbiAgICByZXQucHVzaChjbG9uZShhcnJbaV0sIG9wdGlvbnMpKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogTWVyZ2VzIGBmcm9tYCBpbnRvIGB0b2Agd2l0aG91dCBvdmVyd3JpdGluZyBleGlzdGluZyBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b1xuICogQHBhcmFtIHtPYmplY3R9IGZyb21cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMubWVyZ2UgPSBmdW5jdGlvbiBtZXJnZSh0bywgZnJvbSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGlmIChzcGVjaWFsUHJvcGVydGllcy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgdG9ba2V5XSkge1xuICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGV4cG9ydHMuaXNPYmplY3QoZnJvbVtrZXldKSkge1xuICAgICAgICBtZXJnZSh0b1trZXldLCBmcm9tW2tleV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU2FtZSBhcyBtZXJnZSBidXQgY2xvbmVzIHRoZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRvXG4gKiBAcGFyYW0ge09iamVjdH0gZnJvbVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5tZXJnZUNsb25lID0gZnVuY3Rpb24gbWVyZ2VDbG9uZSh0bywgZnJvbSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGlmIChzcGVjaWFsUHJvcGVydGllcy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgdG9ba2V5XSkge1xuICAgICAgdG9ba2V5XSA9IGNsb25lKGZyb21ba2V5XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChleHBvcnRzLmlzT2JqZWN0KGZyb21ba2V5XSkpIHtcbiAgICAgICAgbWVyZ2VDbG9uZSh0b1trZXldLCBmcm9tW2tleV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9ba2V5XSA9IGNsb25lKGZyb21ba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFJlYWQgcHJlZiBoZWxwZXIgKG1vbmdvIDIuMiBkcml2ZXJzIHN1cHBvcnQgdGhpcylcbiAqXG4gKiBBbGxvd3MgdXNpbmcgYWxpYXNlcyBpbnN0ZWFkIG9mIGZ1bGwgcHJlZmVyZW5jZSBuYW1lczpcbiAqXG4gKiAgICAgcCAgIHByaW1hcnlcbiAqICAgICBwcCAgcHJpbWFyeVByZWZlcnJlZFxuICogICAgIHMgICBzZWNvbmRhcnlcbiAqICAgICBzcCAgc2Vjb25kYXJ5UHJlZmVycmVkXG4gKiAgICAgbiAgIG5lYXJlc3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZlxuICovXG5cbmV4cG9ydHMucmVhZFByZWYgPSBmdW5jdGlvbiByZWFkUHJlZihwcmVmKSB7XG4gIHN3aXRjaCAocHJlZikge1xuICAgIGNhc2UgJ3AnOlxuICAgICAgcHJlZiA9ICdwcmltYXJ5JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3BwJzpcbiAgICAgIHByZWYgPSAncHJpbWFyeVByZWZlcnJlZCc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzJzpcbiAgICAgIHByZWYgPSAnc2Vjb25kYXJ5JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NwJzpcbiAgICAgIHByZWYgPSAnc2Vjb25kYXJ5UHJlZmVycmVkJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ24nOlxuICAgICAgcHJlZiA9ICduZWFyZXN0JztcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHByZWY7XG59O1xuXG5cbi8qKlxuICogUmVhZCBDb25jZXJuIGhlbHBlciAobW9uZ28gMy4yIGRyaXZlcnMgc3VwcG9ydCB0aGlzKVxuICpcbiAqIEFsbG93cyB1c2luZyBzdHJpbmcgdG8gc3BlY2lmeSByZWFkIGNvbmNlcm4gbGV2ZWw6XG4gKlxuICogICAgIGxvY2FsICAgICAgICAgIDMuMitcbiAqICAgICBhdmFpbGFibGUgICAgICAzLjYrXG4gKiAgICAgbWFqb3JpdHkgICAgICAgMy4yK1xuICogICAgIGxpbmVhcml6YWJsZSAgIDMuNCtcbiAqICAgICBzbmFwc2hvdCAgICAgICA0LjArXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjb25jZXJuXG4gKi9cblxuZXhwb3J0cy5yZWFkQ29uY2VybiA9IGZ1bmN0aW9uIHJlYWRDb25jZXJuKGNvbmNlcm4pIHtcbiAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgY29uY2Vybikge1xuICAgIHN3aXRjaCAoY29uY2Vybikge1xuICAgICAgY2FzZSAnbCc6XG4gICAgICAgIGNvbmNlcm4gPSAnbG9jYWwnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICBjb25jZXJuID0gJ2F2YWlsYWJsZSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbSc6XG4gICAgICAgIGNvbmNlcm4gPSAnbWFqb3JpdHknO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2x6JzpcbiAgICAgICAgY29uY2VybiA9ICdsaW5lYXJpemFibGUnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3MnOlxuICAgICAgICBjb25jZXJuID0gJ3NuYXBzaG90JztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbmNlcm4gPSB7IGxldmVsOiBjb25jZXJuIH07XG4gIH1cbiAgcmV0dXJuIGNvbmNlcm47XG59O1xuXG4vKipcbiAqIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCBoZWxwZXJcbiAqL1xuXG5jb25zdCBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuZXhwb3J0cy50b1N0cmluZyA9IGZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwoYXJnKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBgYXJnYCBpcyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl8U3RyaW5nfEZ1bmN0aW9ufFJlZ0V4cHxhbnl9IGFyZ1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5jb25zdCBpc09iamVjdCA9IGV4cG9ydHMuaXNPYmplY3QgPSBmdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuICdbb2JqZWN0IE9iamVjdF0nID09IGV4cG9ydHMudG9TdHJpbmcoYXJnKTtcbn07XG5cbi8qKlxuICogT2JqZWN0LmtleXMgaGVscGVyXG4gKi9cblxuZXhwb3J0cy5rZXlzID0gT2JqZWN0LmtleXM7XG5cbi8qKlxuICogQmFzaWMgT2JqZWN0LmNyZWF0ZSBwb2x5ZmlsbC5cbiAqIE9ubHkgb25lIGFyZ3VtZW50IGlzIHN1cHBvcnRlZC5cbiAqXG4gKiBCYXNlZCBvbiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9jcmVhdGVcbiAqL1xuXG5leHBvcnRzLmNyZWF0ZSA9ICdmdW5jdGlvbicgPT0gdHlwZW9mIE9iamVjdC5jcmVhdGVcbiAgPyBPYmplY3QuY3JlYXRlXG4gIDogY3JlYXRlO1xuXG5mdW5jdGlvbiBjcmVhdGUocHJvdG8pIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBZGRpbmcgcHJvcGVydGllcyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cblxuICBmdW5jdGlvbiBGKCkgeyB9XG4gIEYucHJvdG90eXBlID0gcHJvdG87XG4gIHJldHVybiBuZXcgRjtcbn1cblxuLyoqXG4gKiBpbmhlcml0YW5jZVxuICovXG5cbmV4cG9ydHMuaW5oZXJpdHMgPSBmdW5jdGlvbihjdG9yLCBzdXBlckN0b3IpIHtcbiAgY3Rvci5wcm90b3R5cGUgPSBleHBvcnRzLmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlKTtcbiAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIG9iamVjdCBpcyBhbiBhcmd1bWVudHMgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtBbnl9IHZcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZXhwb3J0cy5pc0FyZ3VtZW50c09iamVjdCA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/utils.js\n");

/***/ })

};
;